<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="AntWhy">
<meta property="og:url" content="http://www.antwhy.com/page/2/index.html">
<meta property="og:site_name" content="AntWhy">
<meta property="og:locale">
<meta property="article:author" content="liyan">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.antwhy.com/page/2/"/>





  <title>AntWhy</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AntWhy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Server Engineer</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.antwhy.com/2017/02/23/9.aspectj-analyze/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AntWhy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/23/9.aspectj-analyze/" itemprop="url">AOP静态、动态代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-23T10:56:45+08:00">
                2017-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x01-AOP简介"><a href="#0x01-AOP简介" class="headerlink" title="0x01.AOP简介"></a><span style="color:#436EEE;font-size:24px">0x01.AOP简介</span></h1><h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a><span style="color:#436EEE;font-size:20px">什么是AOP</span></h2><p><span style="color:#575757;font-size:17px">In computing, aspect-oriented programming (AOP) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. It does so by adding additional behavior to existing code (an advice) without modifying the code itself, instead separately specifying which code is modified via a “pointcut” specification, such as “log all function calls when the function’s name begins with ‘set’”. This allows behaviors that are not central to the business logic (such as logging) to be added to a program without cluttering the code, core to the functionality. AOP forms a basis for aspect-oriented software development.</span> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Aspect-oriented_programming">Wikipedia</a><br>在计算机中,AOP是一种自动增加模块通过横切关注点分离的程序范式。它不需要修改原有的代码实现增加附加的功能在原有代码上,而不是单独指定那段代码通过”pointcut”规范,比如”方法名以’set’开头的所有方法实现日志功能”。这种行为不是核心业务逻辑(比如日志功能)被添加到一个程序无需破坏代码,核心的功能。AOP形式面向切面软件开发的基础。</p>
<h2 id="AOP的作用是什么"><a href="#AOP的作用是什么" class="headerlink" title="AOP的作用是什么"></a><span style="color:#436EEE;font-size:20px">AOP的作用是什么</span></h2><p>AOP作为OOP的一种补充，广泛应用于处理一些具有横切性质的系统级服务，如<span style="color:#FF8C00;font-size:16px">事务管理、安全检查、缓存、对象池管理</span>等。AOP实现的关键就在于AOP框架自动创建的AOP代理，AOP代理则可分为静态代理和动态代理两大类，其中静态代理是指使用AOP框架提供的命令进行编译如AspectJ。而动态代理则在运行时借助于JDK动态代理、CGLIB等在内存中“临时”生成AOP动态代理类。</p>
<h1 id="0x02-静态代理"><a href="#0x02-静态代理" class="headerlink" title="0x02.静态代理"></a><span style="color:#436EEE;font-size:24px">0x02.静态代理</span></h1><p><span style="color:#9BE95A;font-size:16px">静态代理就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强。</span>AspectJ作为典型的静态代理实现,我们来探究下其中的奥秘。</p>
<h2 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a><span style="color:#436EEE;font-size:20px">AspectJ</span></h2><p>AspectJ是最早、功能比较强大的AOP实现之一，基于Java语言的AOP框架，对整套AOP机制都有较好的实现，很多其他语言的AOP实现，也借鉴或采纳了AspectJ中很多设计。在Java领域，AspectJ中的很多语法结构基本上已成为AOP领域的标准。</p>
<p>我们可以到<a target="_blank" rel="noopener" href="http://www.eclipse.org/aspectj">AspectJ官网</a>，下载并安装。我们拿官方的一个例子来感受下AspectJ的用法，并分析AspectJ如何在编译时进行增强。<br><span style="color:#63B8FF;font-size:16px">Demo.java</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Demo d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Demo</span>().go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123;</span><br><span class="line">        d = <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        d.foo(<span class="number">1</span>,d);</span><br><span class="line">        System.out.println(d.bar(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> i, Object o)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Demo.foo(&quot;</span> + i + <span class="string">&quot;, &quot;</span> + o + <span class="string">&quot;)\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">bar</span> <span class="params">(Integer j)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Demo.bar(&quot;</span> + j + <span class="string">&quot;)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Demo.bar(&quot;</span> + j  + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们单独用javac编译Demo.java文件并且执行出来的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ Demo.foo(<span class="number">1</span>, Demo@<span class="number">7852e922</span>)</span><br><span class="line">$ Demo.bar(<span class="number">3</span>)</span><br><span class="line">$ Demo.bar(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>我们接着使用官方AOP范例<span style="color:#63B8FF;font-size:16px">GetInfo.java</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.CodeSignature;</span><br><span class="line"></span><br><span class="line">aspect GetInfo &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String s)</span>&#123; System.out.println(s); &#125;</span><br><span class="line"></span><br><span class="line">   pointcut <span class="title function_">goCut</span><span class="params">()</span>: cflow(<span class="built_in">this</span>(Demo) &amp;&amp; execution(<span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>));</span><br><span class="line"></span><br><span class="line">   pointcut <span class="title function_">demoExecs</span><span class="params">()</span>: within(Demo) &amp;&amp; execution(* *(..));</span><br><span class="line"></span><br><span class="line">   Object <span class="title function_">around</span><span class="params">()</span>: demoExecs() &amp;&amp; !execution(* go()) &amp;&amp; goCut() &#123;</span><br><span class="line">      println(<span class="string">&quot;Intercepted message: &quot;</span> +</span><br><span class="line">          thisJoinPointStaticPart.getSignature().getName());</span><br><span class="line">      println(<span class="string">&quot;in class: &quot;</span> +</span><br><span class="line">          thisJoinPointStaticPart.getSignature().getDeclaringType().getName());</span><br><span class="line">      printParameters(thisJoinPoint);</span><br><span class="line">      println(<span class="string">&quot;Running original method: \n&quot;</span> );</span><br><span class="line">      <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proceed();</span><br><span class="line">      println(<span class="string">&quot;  result: &quot;</span> + result );</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printParameters</span><span class="params">(JoinPoint jp)</span> &#123;</span><br><span class="line">      println(<span class="string">&quot;Arguments: &quot;</span> );</span><br><span class="line">      Object[] args = jp.getArgs();</span><br><span class="line">      String[] names = ((CodeSignature)jp.getSignature()).getParameterNames();</span><br><span class="line">      Class[] types = ((CodeSignature)jp.getSignature()).getParameterTypes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">         println(<span class="string">&quot;  &quot;</span>  + i + <span class="string">&quot;. &quot;</span> + names[i] +</span><br><span class="line">             <span class="string">&quot; : &quot;</span> +            types[i].getName() +</span><br><span class="line">             <span class="string">&quot; = &quot;</span> +            args[i]);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们使用Aspect编译</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ajc Demo.java GetInfo.java</span><br><span class="line">$ java Demo  <span class="comment">//executive command</span></span><br></pre></td></tr></table></figure>
<p>得到结果如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Intercepted message: foo</span><br><span class="line">in class: Demo</span><br><span class="line">Arguments:</span><br><span class="line">  <span class="number">0.</span> i : <span class="type">int</span> = <span class="number">1</span></span><br><span class="line">  <span class="number">1.</span> o : java.lang.Object = Demo@5674cd4d</span><br><span class="line">Running original method:</span><br><span class="line"></span><br><span class="line">Demo.foo(<span class="number">1</span>, Demo@5674cd4d)</span><br><span class="line"></span><br><span class="line">  result: <span class="literal">null</span></span><br><span class="line">Intercepted message: bar</span><br><span class="line">in class: Demo</span><br><span class="line">Arguments:</span><br><span class="line">  <span class="number">0.</span> j : java.lang.Integer = <span class="number">3</span></span><br><span class="line">Running original method:</span><br><span class="line"></span><br><span class="line">Demo.bar(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  result: Demo.bar(<span class="number">3</span>)</span><br><span class="line">Demo.bar(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>对照两次的结果,读者可能已经发行,我们并未修改Demo.java中的代码,但是Demo.java运行出来的结果却出乎我们意料的增加了<span style="color:#63B8FF;font-size:16px">Intercepted message</span>等新功能,为何会有如此神奇的事情产生,我们用java反编译工具来查看下Demo.class文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">import java.io.PrintStream;</span><br><span class="line">import org.aspectj.lang.JoinPoint;</span><br><span class="line">import org.aspectj.lang.JoinPoint.StaticPart;</span><br><span class="line">import org.aspectj.lang.Signature;</span><br><span class="line">import org.aspectj.runtime.internal.AroundClosure;</span><br><span class="line">import org.aspectj.runtime.internal.CFlowCounter;</span><br><span class="line">import org.aspectj.runtime.internal.Conversions;</span><br><span class="line">import org.aspectj.runtime.reflect.Factory;</span><br><span class="line"></span><br><span class="line">public class Demo</span><br><span class="line">&#123;</span><br><span class="line">  static Demo d;</span><br><span class="line">  private static final JoinPoint.StaticPart ajc$tjp_0;</span><br><span class="line">  private static final JoinPoint.StaticPart ajc$tjp_1;</span><br><span class="line">  private static final JoinPoint.StaticPart ajc$tjp_2;</span><br><span class="line">  </span><br><span class="line">  public static void main(String[] args)</span><br><span class="line">  &#123;</span><br><span class="line">    String[] arrayOfString = args;JoinPoint localJoinPoint = Factory.makeJP(ajc$tjp_0, null, null, arrayOfString);</span><br><span class="line">    if (GetInfo.ajc$cflowCounter$0.isValid())</span><br><span class="line">    &#123;</span><br><span class="line">      main_aroundBody1$advice(arrayOfString, localJoinPoint, GetInfo.aspectOf(), null, ajc$tjp_0, localJoinPoint);return;</span><br><span class="line">    &#125;</span><br><span class="line">    main_aroundBody0(arrayOfString, localJoinPoint);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  void foo(int i, Object o)</span><br><span class="line">  &#123;</span><br><span class="line">    int i = i;Object localObject = o;JoinPoint localJoinPoint = Factory.makeJP(ajc$tjp_1, this, this, Conversions.intObject(i), localObject);</span><br><span class="line">    if (GetInfo.ajc$cflowCounter$0.isValid())</span><br><span class="line">    &#123;</span><br><span class="line">      foo_aroundBody3$advice(this, i, localObject, localJoinPoint, GetInfo.aspectOf(), null, ajc$tjp_1, localJoinPoint);return;</span><br><span class="line">    &#125;</span><br><span class="line">    foo_aroundBody2(this, i, localObject, localJoinPoint);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  String bar(Integer j)</span><br><span class="line">  &#123;</span><br><span class="line">    Integer localInteger = j;JoinPoint localJoinPoint = Factory.makeJP(ajc$tjp_2, this, this, localInteger);</span><br><span class="line">    if (GetInfo.ajc$cflowCounter$0.isValid()) &#123;</span><br><span class="line">      return (String)bar_aroundBody5$advice(this, localInteger, localJoinPoint, GetInfo.aspectOf(), null, ajc$tjp_2, localJoinPoint);</span><br><span class="line">    &#125;</span><br><span class="line">    return bar_aroundBody4(this, localInteger, localJoinPoint);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private static void ajc$preClinit()</span><br><span class="line">  &#123;</span><br><span class="line">    Factory localFactory = new Factory(&quot;Demo.java&quot;, Class.forName(&quot;Demo&quot;));ajc$tjp_0 = localFactory.makeSJP(&quot;method-execution&quot;, localFactory.makeMethodSig(&quot;9-main-Demo-[Ljava.lang.String;:-args:--void-&quot;), 17);ajc$tjp_1 = localFactory.makeSJP(&quot;method-execution&quot;, localFactory.makeMethodSig(&quot;0-foo-Demo-int:java.lang.Object:-i:o:--void-&quot;), 27);ajc$tjp_2 = localFactory.makeSJP(&quot;method-execution&quot;, localFactory.makeMethodSig(&quot;0-bar-Demo-java.lang.Integer:-j:--java.lang.String-&quot;), 31);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private static final void main_aroundBody0(String[] args, JoinPoint paramJoinPoint)</span><br><span class="line">  &#123;</span><br><span class="line">    new Demo().go();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  void go()</span><br><span class="line">  &#123;</span><br><span class="line">    GetInfo.ajc$cflowCounter$0.inc();</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      d = new Demo();</span><br><span class="line">      d.foo(1, d);</span><br><span class="line">      System.out.println(d.bar(new Integer(3)));</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      GetInfo.ajc$cflowCounter$0.dec();throw localThrowable;</span><br><span class="line">    &#125;</span><br><span class="line">    GetInfo.ajc$cflowCounter$0.dec();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private static final void foo_aroundBody2(Demo ajc$this, int i, Object o, JoinPoint paramJoinPoint)</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(&quot;Demo.foo(&quot; + i + &quot;, &quot; + o + &quot;)\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private static final Object main_aroundBody1$advice(String[] args, JoinPoint thisJoinPoint, GetInfo ajc$aspectInstance, AroundClosure ajc$aroundClosure, JoinPoint.StaticPart thisJoinPointStaticPart, JoinPoint thisJoinPoint)</span><br><span class="line">  &#123;</span><br><span class="line">    GetInfo.ajc$inlineAccessMethod$GetInfo$GetInfo$println(</span><br><span class="line">      &quot;Intercepted message: &quot; + thisJoinPointStaticPart.getSignature().getName());</span><br><span class="line">    GetInfo.ajc$inlineAccessMethod$GetInfo$GetInfo$println(&quot;in class: &quot; + </span><br><span class="line">      thisJoinPointStaticPart.getSignature().getDeclaringType().getName());</span><br><span class="line">    GetInfo.ajc$inlineAccessMethod$GetInfo$GetInfo$printParameters(thisJoinPoint);</span><br><span class="line">    GetInfo.ajc$inlineAccessMethod$GetInfo$GetInfo$println(&quot;Running original method: \n&quot;);</span><br><span class="line">    AroundClosure localAroundClosure = ajc$aroundClosure;main_aroundBody0(args, thisJoinPoint);Object result = null;</span><br><span class="line">    GetInfo.ajc$inlineAccessMethod$GetInfo$GetInfo$println(&quot;  result: &quot; + result);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private static final Object foo_aroundBody3$advice(Demo ajc$this, int i, Object o, JoinPoint thisJoinPoint, GetInfo ajc$aspectInstance, AroundClosure ajc$aroundClosure, JoinPoint.StaticPart thisJoinPointStaticPart, JoinPoint thisJoinPoint)</span><br><span class="line">  &#123;</span><br><span class="line">    GetInfo.ajc$inlineAccessMethod$GetInfo$GetInfo$println(</span><br><span class="line">      &quot;Intercepted message: &quot; + thisJoinPointStaticPart.getSignature().getName());</span><br><span class="line">    GetInfo.ajc$inlineAccessMethod$GetInfo$GetInfo$println(&quot;in class: &quot; + </span><br><span class="line">      thisJoinPointStaticPart.getSignature().getDeclaringType().getName());</span><br><span class="line">    GetInfo.ajc$inlineAccessMethod$GetInfo$GetInfo$printParameters(thisJoinPoint);</span><br><span class="line">    GetInfo.ajc$inlineAccessMethod$GetInfo$GetInfo$println(&quot;Running original method: \n&quot;);</span><br><span class="line">    AroundClosure localAroundClosure = ajc$aroundClosure;foo_aroundBody2(ajc$this, i, o, thisJoinPoint);Object result = null;</span><br><span class="line">    GetInfo.ajc$inlineAccessMethod$GetInfo$GetInfo$println(&quot;  result: &quot; + result);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private static final String bar_aroundBody4(Demo ajc$this, Integer j, JoinPoint paramJoinPoint)</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(&quot;Demo.bar(&quot; + j + &quot;)\n&quot;);</span><br><span class="line">    return &quot;Demo.bar(&quot; + j + &quot;)&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private static final Object bar_aroundBody5$advice(Demo ajc$this, Integer j, JoinPoint thisJoinPoint, GetInfo ajc$aspectInstance, AroundClosure ajc$aroundClosure, JoinPoint.StaticPart thisJoinPointStaticPart, JoinPoint thisJoinPoint)</span><br><span class="line">  &#123;</span><br><span class="line">    GetInfo.ajc$inlineAccessMethod$GetInfo$GetInfo$println(</span><br><span class="line">      &quot;Intercepted message: &quot; + thisJoinPointStaticPart.getSignature().getName());</span><br><span class="line">    GetInfo.ajc$inlineAccessMethod$GetInfo$GetInfo$println(&quot;in class: &quot; + </span><br><span class="line">      thisJoinPointStaticPart.getSignature().getDeclaringType().getName());</span><br><span class="line">    GetInfo.ajc$inlineAccessMethod$GetInfo$GetInfo$printParameters(thisJoinPoint);</span><br><span class="line">    GetInfo.ajc$inlineAccessMethod$GetInfo$GetInfo$println(&quot;Running original method: \n&quot;);</span><br><span class="line">    AroundClosure localAroundClosure = ajc$aroundClosure;Object result = bar_aroundBody4(ajc$this, j, thisJoinPoint);</span><br><span class="line">    GetInfo.ajc$inlineAccessMethod$GetInfo$GetInfo$println(&quot;  result: &quot; + result);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  static &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到Demo.class文件不是由原来的Demo.java文件编译得到的,里面新增了好多内容–这个说明AspectJ在编译时自动编译得到了一个新类,这个新类增强了Demo.java类的功能。</p>
<p>AspectJ实际类似于javac编译工具,我们刚才看到的GetInfo.java属于AspectJ的专有语法,它编译的目标跟javac一样的都是java class文件，只是源文件的语法是符合aspect语法的。AspectJ理解编译时期对源文件按照指定的描述（aspect语法文件）进行编译，得到进行切入后的字节码文件。</p>
<p><span style="color:#63B8FF;font-size:17px">pointcut:</span>描述切面内容，可以理解为针对哪些方法，类，进行拦截，插入代码。<br><span style="color:#63B8FF;font-size:17px">around:</span>实际上拦截方法，这个注解可以同时拦截方法的执行前后，另外有before, after，顾名思义，表示方法执行前跟方法执行后拦截。proceed()代表原方法执行</p>
<h1 id="0x03-动态代理"><a href="#0x03-动态代理" class="headerlink" title="0x03.动态代理"></a><span style="color:#436EEE;font-size:24px">0x03.动态代理</span></h1><h2 id="JDK原生动态代理"><a href="#JDK原生动态代理" class="headerlink" title="JDK原生动态代理"></a><span style="color:#436EEE;font-size:20px">JDK原生动态代理</span></h2><p>动态代理的话常用<span style="color:#63B8FF;font-size:16px">JDK原生动态代理和CGLIB动态代理</span>,首先我们来看下JDK原生动态代理的实现。<br>我们定义一个<span style="color:#63B8FF;font-size:16px">JDKDemo</span>接口,并<span style="color:#63B8FF;font-size:16px">JDKDemoImpl</span>实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JDKDemo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKDemoImpl</span> <span class="keyword">implements</span> <span class="title class_">JDKDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;go &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来,我们定义<span style="color:#63B8FF;font-size:16px">JDKDemoProxy</span>代理类实现<span style="color:#63B8FF;font-size:16px">JDKDemo</span>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKDemoProxy</span> <span class="keyword">implements</span> <span class="title class_">JDKDemo</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  JDKDemo jdkDemo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JDKDemoProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        jdkDemo = <span class="keyword">new</span> <span class="title class_">JDKDemoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        jdkDemo.go(name);</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;JDKDemoProxy Before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;JDKDemoProxy After&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们定义<span style="color:#63B8FF;font-size:16px">DynamicProxy</span>实现InvocationHandler，方法调用会被转发到该类的invoke()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicProxy</span><span class="params">(Object target)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="built_in">this</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">            <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span>method.invoke(target,args);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DynamicProxy Before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DynamicProxy After&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的关键是<span style="color:#EE2C2C;font-size:16px">Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler)</span>方法，该方法会根据指定的参数动态创建代理对象。三个参数的意义如下：</p>
<ol>
<li>ClassLoader loader 指定代理对象的类加载器；</li>
<li>Class&lt;?&gt;[] interfaces，代理对象需要实现的接口，可以同时指定多个接口；</li>
<li>InvocationHandler h，方法调用的实际处理者，代理对象的方法调用都会转发到这里</li>
</ol>
<p><span style="color:#836FFF;font-size:16px">newProxyInstance()</span>会返回一个实现了指定接口的代理对象，对该对象的所有方法调用都会转发给InvocationHandler.invoke()方法。invoke()方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等。</p>
<p>最后我们来测试下动态代理的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">proxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DynamicProxy</span> <span class="variable">dynamicProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicProxy</span>(<span class="keyword">new</span> <span class="title class_">JDKDemoProxy</span>());</span><br><span class="line">        <span class="type">JDKDemo</span> <span class="variable">jdkDemo</span> <span class="operator">=</span> dynamicProxy.getProxy();</span><br><span class="line">        jdkDemo.go(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DynamicProxy Before</span><br><span class="line">JDKDemoProxy Before</span><br><span class="line">go banana</span><br><span class="line">JDKDemoProxy After</span><br><span class="line">DynamicProxy After</span><br></pre></td></tr></table></figure>
<p>Java动态代理为我们提供了非常灵活的代理机制，但Java动态代理是基于接口的，对象没有实现接口的情况无法使用。</p>
<h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a><span style="color:#436EEE;font-size:20px">CGLIB动态代理</span></h2><p>JDK动态代理无法解决没有实现接口的情况,这种情况下就可以使用cglib。</p>
<p>创建<span style="color:#63B8FF;font-size:16px">CglibDemo.java</span>,定义go方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;go cglib&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color:#63B8FF;font-size:16px">CglibMethodInterceptor.java</span><br>实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before:&quot;</span>+method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;After:&quot;</span>+method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color:#76EEC6;font-size:16px">CGLIG中MethodInterceptor的作用跟JDK代理中的InvocationHandler</span>很类似，都是方法调用的中转站。</p>
<p><span style="color:#63B8FF;font-size:16px">AOPTest.java</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cglib</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(CglibDemo.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">CglibMethodInterceptor</span>());</span><br><span class="line">        <span class="type">CglibDemo</span> <span class="variable">cglibDemo</span> <span class="operator">=</span> (CglibDemo)enhancer.create();</span><br><span class="line">        cglibDemo.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span style="color:#EE2C2C;font-size:16px">Enhancer是CGlib的字节码增强器</span>。代理类对象是由Enhancer类创建的,可以很方便的对类进行拓展。<br>通过CGLIB的Enhancer来指定要代理的目标对象、实际处理代理逻辑的对象，最终通过<span style="color:#76EEC6;font-size:16px">调用create()方法得到代理对象</span>，对这个对象所有<span style="color:#EE2C2C;font-size:16px">非final方法</span>(<span style="color:#C1C1C1;font-size:16px">CGLIB是通过继承实现代理,无法处理final</span>)的调用都会转发给MethodInterceptor.intercept()方法，在intercept()方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等；通过调用MethodProxy.invokeSuper()方法，我们将调用转发给原始对象。</p>
<p><span style="color:#EE2C2C;font-size:16px">Spring AOP</span>的动态代理也是基于CGlib,在每次运行时动态的增强，生成AOP代理对象，区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p>
<h1 id="0x01-参考链接"><a href="#0x01-参考链接" class="headerlink" title="0x01.参考链接"></a><span style="color:#436EEE;font-size:24px">0x01.参考链接</span></h1><p><a target="_blank" rel="noopener" href="http://www.eclipse.org/aspectj">1. http://www.eclipse.org/aspectj</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Aspect-oriented_programming">2. https://en.wikipedia.org/wiki/Aspect-oriented_programming</a><br><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Proxy.html">3. https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Proxy.html</a><br><a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">4. https://github.com/cglib/cglib</a><br><a target="_blank" rel="noopener" href="https://github.com/cglib/cglib/wiki/How-To#access-the-generated-byte-array-directly">5. https://github.com/cglib/cglib/wiki/How-To#access-the-generated-byte-array-directly</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.antwhy.com/2016/08/12/4.javac%20compiler-basis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AntWhy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/12/4.javac%20compiler-basis/" itemprop="url">初窥javac编译器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-12T10:04:20+08:00">
                2016-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/technotes/tools/windows/javac.html#description">javac</a>作为Java的编译器,感觉跟我们又关系不大,但其实跟我们写的每一个代码都息息相关,我们用ide工具写代码,写一个hello world,然后run,就直接能看到输出hello world,其实ide帮我们调用Javac进行过编译.今天就抛开ide,来直接体验下Javac的强大.</p>
<h1 id="2-例子-Hello-World"><a href="#2-例子-Hello-World" class="headerlink" title="2.例子,Hello World"></a>2.例子,Hello World</h1><p>我们先来编译第一个程序hello world</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>javac HelloWorld.java</code> ,编译完后我们得到一个HelloWorld.class文件,打开文件,我们发现除了开头<code>cafe babe</code>的标示外,完全看不懂的字节码文件.<br>那我们先用<code>javap -c HelloWorld.class</code>把这个字节码反编译看看里面的内容<code>Compiled from &quot;HelloWorld.java&quot;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  public <span class="title class_">HelloWorld</span>();</span><br><span class="line">    <span class="title class_">Code</span>:</span><br><span class="line">       <span class="number">0</span>: aload_0                           <span class="comment">// 加载本地变量的引用 (非静态方法中，aload_0表示对this的操作，在static方法中，aload_0表示对方法的第一参数的操作)</span></span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  public <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(java.<span class="property">lang</span>.<span class="property">String</span>[]);</span><br><span class="line">    <span class="title class_">Code</span>:</span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String Hello World (ldc将常量入栈)</span></span><br><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考反编译出来的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.aaload">jvm指令集</a>,我们可以获取的信息包括,<code>javac</code>编译java文件时,会默认添加一个init初始化方法,然后看到main方法中,通过<code>getstatic</code>获取类的静态字段,<code>ldc</code>指令将字符常量入栈,然后在进行print<br>方法名后面<code>#2 #3</code>等等,指的是<a target="_blank" rel="noopener" href="https://www.programcreek.com/2013/04/jvm-run-time-data-areas/">运行期常量池</a>,具体含义可以使用<code>javap -v HelloWorld.class</code>查看 </p>
<h1 id="3-javac"><a href="#3-javac" class="headerlink" title="3.javac"></a>3.javac</h1><p>通过这个简单的例子,我们看到了javac编译java文件生成jvm去加载的class文件,那javac编译期间做过哪些事情呢。如下图:<br><img src="https://d26dzxoao6i3hh.cloudfront.net/items/2E3M1r433J1Y071s0d2A/QQ20171211-154922@2x.png?v=fbf393b6"></p>
<h2 id="3-1JavaCompiler"><a href="#3-1JavaCompiler" class="headerlink" title="3.1JavaCompiler"></a>3.1JavaCompiler</h2><p>Javac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类,类中的<code>compile</code>和<code>compile2</code>函数包含了主要的编译逻辑<br><img src="https://d26dzxoao6i3hh.cloudfront.net/items/3z302t0C0j0f2e2n290B/20171112212604.png?v=74e09bfb"><br><img src="https://d26dzxoao6i3hh.cloudfront.net/items/2j2O2F3b2p1k2l1o452u/20171112214041.png?v=476fa53f"></p>
<h2 id="3-2词法分析"><a href="#3-2词法分析" class="headerlink" title="3.2词法分析"></a>3.2词法分析</h2><p>词法分析就是逐个字符读取源码,然后按照一定的规范形成token流,规范如 </p>
<ul>
<li>符号 + - * &#x2F; &#x3D; ; % { } 等</li>
<li>关键字 private package abstract import boolean true spuer 等</li>
<li>自定义单词：包名、类名、变量名、方法名 </li>
<li>所有token规范位于<code>com.sun.tools.javac.parser.token</code></li>
</ul>
<p><img src="https://d26dzxoao6i3hh.cloudfront.net/items/1B0T2L3X0m0k2F2u3Y22/20171116-232400@2x.png?v=67e4e545"></p>
<p><code>com.sun.tools.javac.parser.JavacParser</code>类 制定语法规范</p>
<p><img src="https://d26dzxoao6i3hh.cloudfront.net/items/2O3F3o2g1p1V3K1j1v0R/20171116-230037@2x.png?v=eb6b635e"></p>
<p><code>com.sun.tools.javac.parser.Scanner</code>包中进行进行字符解析,根据<code>JavacParser</code>中语法规范,构造Token; </p>
<p>我们来看一个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> helloWorld;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloAnt</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">50.00</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span> + a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据规范转换成token流<br><img src="https://d26dzxoao6i3hh.cloudfront.net/items/0M152p1y1407073b3q1N/20171115-230641@2x.png?v=7c911e22"></p>
<h2 id="3-3语法分析"><a href="#3-3语法分析" class="headerlink" title="3.3语法分析"></a>3.3语法分析</h2><p>语法分析就是按照相应的规范将token组成句子。</p>
<p><img src="https://d26dzxoao6i3hh.cloudfront.net/items/0u0W14030A1S0c0t0j1C/20171116-230039@2x.jpg?v=290d152f"></p>
<p><code>JCTree.java</code>类包含语法节点规范</p>
<p><img src="https://d26dzxoao6i3hh.cloudfront.net/items/1q2S0q2C3Q1W3v0S2u0n/20171117-150735@2x.png?v=95c3bca7"></p>
<p><code>TreeMaker.java</code>将Token流构造成语法树</p>
<p><img src="https://d26dzxoao6i3hh.cloudfront.net/items/1p1u0P1x3R1S042A201R/QQ20171209-000537.png?v=4171bc22"><br>根据示例代码构建的一棵语法树,语法树的<code>top-level为JCCompilationUnit</code>,接着是包名,然后包含类,类又包含各个方法等等</p>
<h2 id="3-4语义分析"><a href="#3-4语义分析" class="headerlink" title="3.4语义分析"></a>3.4语义分析</h2><p>语义分析的目的就是把语法树转化成抽象语法树(abstract syntax tree)AST,步骤包括 </p>
<ol>
<li>检查语义的合理性并进行逻辑判断，类型是否匹配，是否初始化，泛型是否可推导，字符串常量合并等 </li>
<li>数据流分析 </li>
<li>语法树转换抽象语法树<br>抽象语法树通常还被用来进行代码语法的检查、代码风格的检查、代码的格式化、代码的高亮、代码错误提示、代码自动补全等等</li>
</ol>
<p>编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但<br>无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确的源程序进行上下文<br>有关性质的审查，如进行类型审查。<br>是否合乎语义逻辑必须限定在具体的语言与具体的上下文环境之中才有意义。<br>标注检查 Javac 的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步 骤。<br>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是<br>否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠。<br>由于编译期间进行了常量折叠，所以在代码里面定义” a&#x3D; 1+ 2” 比起直接定义” a&#x3D; 3”， 并不会 增加程序运行期哪怕仅仅一个 CPU 指令的运算量。 </p>
<h3 id="3-4-1数据及控制流分析"><a href="#3-4-1数据及控制流分析" class="headerlink" title="3.4.1数据及控制流分析"></a>3.4.1数据及控制流分析</h3><p>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在<br>使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了<br>等问题。<br>将局部变量声明为 final， 对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保 障。局部变量与字段(实例变量、类变量)是有区别的，它在常量池中没有 CONSTANT_Fieldref_info 的符号引用，自然就没有访问标志( Access_Flags) 的信息。 </p>
<h3 id="3-4-2解语法糖"><a href="#3-4-2解语法糖" class="headerlink" title="3.4.2解语法糖"></a>3.4.2解语法糖</h3><p>在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。<br>解语法糖的过程由 desugar() 方法触发。 </p>
<h2 id="3-5字节码"><a href="#3-5字节码" class="headerlink" title="3.5字节码"></a>3.5字节码</h2><p>字节码生成是 Javac 编译过程的最后一个阶段<br>把前面各个步骤所生成的信息(语法树、符号表)转化成字节码写到磁盘中，编译器还进行 了少量的代码添加和转换工作。例如，前面章节中多次提到的实例构造器 &lt; init &gt; ()方法和 类构造器 &lt; clinit &gt; ()方法就是在这个阶段添加到语法树之中的<br>还有其他的一些代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替换为 StringBuffer 或 StringBuilder。<br>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给 com. sun. tools. javac. jvm. ClassWriter 类，由这个类的 writeClass() 方法输出字节码，生成最终的 Class 文件，到此为止整个编译过程宣告结束。</p>
<p>抽象语法树根据jvm字节码规则转换成对应的字节码,生成class文件,<a target="_blank" rel="noopener" href="http://viralpatel.net/blogs/tutorial-java-class-file-format-revealed/">class语法格式</a></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/technotes/tools/windows/javac.html">1.javac - Java programming language compiler</a><br><a target="_blank" rel="noopener" href="http://www.docjar.com/docs/api/com/sun/tools/javac/tree/JCTree.html">2.Abstract public class: JCTree </a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/tyler_download/article/details/51382346">3.代码实现Thompson构造：由简单到复杂的构建NFA状态机</a><br><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/609ea77ebbaf">4.词法分析器—自动生成器</a><br><a target="_blank" rel="noopener" href="http://fullstack.blog/2017/06/24/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%92%8C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86/#WebAssembly">5.大前端开发者需要了解的基础编译原理和语言知识</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/zhouhuozhi/article/details/4250258">6.抽象语法树(AST)</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000000638838">7.Java代码分析器(二): 使用DOM API操作抽象语法树</a><br><a target="_blank" rel="noopener" href="http://openjdk.java.net/groups/compiler/">8.OpenJDK The Java programming language Compiler Group</a> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.antwhy.com/2016/07/19/3.Deep%20understanding%20of%20the%20Java%20virtual%20machine%20-%20reading%20notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AntWhy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/19/3.Deep%20understanding%20of%20the%20Java%20virtual%20machine%20-%20reading%20notes/" itemprop="url">深入理解Java虚拟机--文摘</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-19T18:14:00+08:00">
                2016-07-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Java内存区域与内存溢出异常"><a href="#1-Java内存区域与内存溢出异常" class="headerlink" title="1.Java内存区域与内存溢出异常"></a>1.Java内存区域与内存溢出异常</h1><p>Java虚拟机运行时数据区,如图<br><img src="https://d26dzxoao6i3hh.cloudfront.net/items/270P1s1F2x420s3F241j/QQ20171220-112906@2x.png?v=d680dc1b"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器:是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示<br>器。每个线程都有自己的独立的程序计数器。 </p>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>线程私有的，它的生命周期与线程相同<br>如果线程请求栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常;无法申请 到内存抛出OutOfMemoryError异常。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟 机执行java方法，而本地栈则为虚拟机使用到的Native方法服务。</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java堆是线程共享的，在虚拟机启动时创建。此区域的唯一目的就是存放对象实例，几乎所 有的对象实例都在这里分配内存。<br>Java堆是垃圾收集器管理的主要区域,通过-Xmx和-Xms控制大小</p>
<h2 id="方法区-永久代"><a href="#方法区-永久代" class="headerlink" title="方法区(永久代)"></a>方法区(永久代)</h2><p>线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码<br>等数据</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>方法区的一部分,用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加 载后进入方法区的运行时常量池中存放。</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>一种基于通道与缓存区(buffer)的I&#x2F;O方式，它可以使用 Native函数库直接分配堆外内存,避免了在Java堆和 Native堆中来回复制数据,显著提高性能</p>
<h1 id="2-HotSpot虚拟机对象探秘"><a href="#2-HotSpot虚拟机对象探秘" class="headerlink" title="2.HotSpot虚拟机对象探秘"></a>2.HotSpot虚拟机对象探秘</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>1.虚拟机遇到一个new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符 号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那 必须先执行相应的类加载过程<br>2.内存的分配是同步的，如果一个线程刚分配一个对象内存，但是还没有修改指针所指向 的位置，那么另一个线程分配对象的时候可能就出错了。解决方法有两个:1.一是对分配内存 空间的动作进行同步处理(CAS方式)。2.另一种是把内存分配的动作按照线程划分在不同的 空间进行，每个线程在java堆中预分配一小块内存，称为本地线程分配缓冲(TLAB)。只有 TLAB用完并分配新的TLAB时，才需要同步。<br>3.JVM对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元 数据信息、对象的哈希码、对象的GC分代年龄等信息</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>   在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域:对象头、实例数据和对齐 填充。<br>   对象头包括两部分信息，第一部分用于存储对象自身的运行时数据(哈希 码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的 存储官方称为Mark Word)，另一部分是类型指针(即对象指向它的类元数据的指针，JVM通 过这个指针来确定这个对象是哪个类的实例<br>  对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。不满8 个字节的时候占位。</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>Java程序需要通过栈上的Reference数据来操作堆上的具体对象。Reference访问对象 的方式目前主流的有两种:句柄和直接指针。<br>句柄来访问的最大好处是reference中存储的是稳定的句 柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。<br>直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销</p>
<h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><p>JVM参数设置<br>-XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机在出现内存溢出异常时，Dump当前的内 存堆转储快照以便事后进行分析。<br>-XX:+HeapDumpOnCtrlBreak 发生崩溃性的错误时,按需获取堆转储文件。堆转储文件可以通过内存分析工具分析 <a target="_blank" rel="noopener" href="http://blog.csdn.net/aaa2832/article/details/19419679">1.内存分析工具 MAT 的使用</a> <a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/opensource/os-cn-ecl-ma/">2.Eclipse Memory Analyzer</a></p>
<h2 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h2><p>HotSpot虚拟机中并不区分虚拟机栈和本地方法栈</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，将抛出OutOfMemoryError异常。</li>
</ul>
<p>如果是建立过多线程导致内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只 能通过减少最大堆和减少栈容量来换取更多的线程。</p>
<h2 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h2><p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。 对于这些区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。<br>使用到<a target="_blank" rel="noopener" href="https://github.com/cglib/cglib/wiki/Tutorial">CGLib</a>这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class 可以加载入内存</p>
<h2 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h2><p>DirectMemory容量可以通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆 最大值(-Xmx指定)一样</p>
<p>由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异 常，如果读者发现OOM之后Dump文件很小，而程序中又直接或者间接使用了NIO，那就可以 考虑检查一下是不是这方面的原因。</p>
<h1 id="3-垃圾收集器与内存分配策略"><a href="#3-垃圾收集器与内存分配策略" class="headerlink" title="3.垃圾收集器与内存分配策略"></a>3.垃圾收集器与内存分配策略</h1><p>GC要完成3件事:</p>
<ol>
<li>哪些内存需要回收? </li>
<li>什么时候回收?</li>
<li>如何回收?</li>
</ol>
<p>Java内存的程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭;<br>Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中 的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间时才能知道会创建哪些对象,这部分内存的分配和回收是动态的，垃 圾收集器所关注的是这部分的内存。</p>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>Java中使用可达性分析(Reachability Analysis)来判定对象是否存活的。<br>“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的 路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连时，则证 明此对象是不可用的。<br>在Java语言中，可作为GC Roots的对象包括下面几种:</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI(即一般说的Native方法)引用的对象。</li>
</ul>
<h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><p>Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)</p>
<ul>
<li>强引用就是指在程序代码之中普遍存在的，类似“Object obj &#x3D; new Object()”这类的引 用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li>软引用是用来描述一些还有用但并非必需的对象。</li>
<li>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的 对象只能生存到下一次垃圾收集发生之前</li>
<li>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统 通知</li>
</ul>
<h2 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h2><p>如果对象在进行可达性分析 后发现没有与GC Roots相连接，那么它将会被第一次标记且进行一次刷选,刷选的条件是此 对象是否有必要执行finalize方法。当对象没有覆盖finalize方法，或者finalize方法已经被虚拟 机调用过，虚拟机将这两种情况都视为“没有必要执行”。如果对象要在finalize方法中拯救自己—只要重新与引用链上的任何 一个对象建立关联即可。但是一个对象的finalize方法只能被执行一次。</p>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>永久代的垃圾回收主要回收两部分内容:废弃常量和无用的类。“废弃常量”判断比较简单，但 是“无用的类”的判断复杂一些，需要满足下面3个条件:</p>
<ul>
<li>该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方 法。</li>
</ul>
<h1 id="4-垃圾收集算法"><a href="#4-垃圾收集算法" class="headerlink" title="4.垃圾收集算法"></a>4.垃圾收集算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>算法分为标记和清除两个阶段:首先标记出所有需要回收的对象，在标记完成后统一回收所<br>有被标记的对象，它的标记过程就是使用可达性算法进行标记的。</p>
<h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p>复制算法:将可用内存按照容量分为大小相等的两块，每次只使用其中的一块。当这一块的<br>内存用完了，就将还存活着的对象复制到另一块上面，然后把已使用过的内存空间一次清理<br>掉。</p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>标记整理算法(Mark-Compact)，标记过程仍然和“标记-清除”一样，但后续不走不是直接对 可回收对象进行清理，而是让所有存活对象向一端移动，然后直接清理掉端边界以外的内 存。</p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>根据对象存活周期的不同将内存分为几块。一般把Java堆分为新生代和老年代，根据各个年 代的特点采用最合适的收集算法。在新生代中，每次垃圾收集时有大批对象死去，只有少量 存活，可以选用复制算法。而老年代对象存活率高，使用标记清理或者标记整理算法。</p>
<h1 id="4-HotSpot的算法实现"><a href="#4-HotSpot的算法实现" class="headerlink" title="4.HotSpot的算法实现"></a>4.HotSpot的算法实现</h1><h2 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h2><p>在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到找到引用对象这个目的的</p>
<h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>实际上，HotSpot没有为每条指令都生成OopMap，<a target="_blank" rel="noopener" href="http://blog.csdn.net/iter_zc/article/details/41847887">SafePoint 安全点</a> 的选定基本上是以程 序“是否具有让程序长时间执行的特征”为标准选定的,“长时间执行”的最明显特征 就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会 产生Safepoint。</p>
<h2 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h2><p>当程序没有被分配 cpu时间，典型的例子就是线程处于sleep或者blocked状态，这个时候线程无法响应JVM的中 断请求，“走”到安全点挂起。对于这种情况，就需要安全区域来解决。我们也可以把Safe Region看做是被扩展的Safepoint。<br>JVM参数 -XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount&#x3D;1 来输出safepoint的统计信息</p>
<h1 id="6-垃圾收集器"><a href="#6-垃圾收集器" class="headerlink" title="6.垃圾收集器"></a>6.垃圾收集器</h1><p>下面是Sun HotSpot虚拟机收集器。<br><img src="https://d26dzxoao6i3hh.cloudfront.net/items/3n1a0x1X470y3l3E0I3X/QQ20171220-175724@2x.png?v=bd83fb7a"></p>
<h2 id="Serial-Collecor"><a href="#Serial-Collecor" class="headerlink" title="Serial Collecor"></a>Serial Collecor</h2><p>Serial收集器是单线程收集器，是分代收集器。它进行垃圾收集时，必须暂停其他所有的工作 线程，直到它收集结束。<br>新生代:单线程复制收集算法;老年代:单线程标记整理算法。</p>
<p>Serial一般在单核的机器上使用，是Java 5非服务端JVM的默认收集器</p>
<h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>Serial收集器无法充分利用物理机的CPU资 源，因此出现了Parallel收集器。Parallel收集器和Serial收集器的主要区别是新生代的收集， 一个是单线程一个是多线程。</p>
<h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p>一个新生代收集器，使用复制算法的收集器，又是并行(用户线程阻塞)的多线程收集器。<br>目标是达到一个可控制的吞吐量。</p>
<h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><p>Serial Old是Serial收集器的老年代版本，它同样是单线程的。使用“标记-整理”算法。</p>
<h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>Parallel old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个 收集器是在JDK1.6中才开始提供的。</p>
<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>也称“low-latency collector”，为了解决老年代暂停时间过长的问题，并且真正实现并行收集 (程序和GC并行执行)。是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基 于“标记-清除”算法实现的。<br>此收集器的不足是，老年代收集采用标记清除算法，因此会产生很多不连续的内存碎片。</p>
<p>此收集器一般多用于对 程序暂停时间要求更短的程序上，多由于web应用(实时性要求高)。参数-<br>XX:+UseConcMarkSweepGC设置使用它。</p>
<h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1是一款面向服务端应用的垃圾收集器。它具有以下几个特点:</p>
<ul>
<li>并行与并发:G1能充分利用多CPU、多核环境下的硬件优势。</li>
<li>分代收集</li>
<li>空间整合:基于“标记-整理”算法实现的收集器。</li>
<li>可预测的停顿:这是G1相对于CMS的另一大优势。</li>
</ul>
<h2 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>UseConcMarkSweepGC</td>
<td>直接晋升到老年代的对象大小，设置这个参数后,大于这个参数的对象将直接在老年代分配</td>
</tr>
<tr>
<td>MaxTenuringThreshold</td>
<td>晋升到老年代的对象年龄。每个对象在坚持过一次 Minor GC之后，年龄就增加1，当超过这个参数值 时就进入老年代</td>
</tr>
<tr>
<td>UseAdaptiveSizePolicy</td>
<td>动态调整Java堆中各个区域的大小以及进入老年代 的年龄</td>
</tr>
<tr>
<td>ParallelGCThreads</td>
<td>设置并行GC时进行内存回收的线程数</td>
</tr>
<tr>
<td>MaxGCPauseMillis</td>
<td>设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效</td>
</tr>
</tbody></table>
<h1 id="6-内存分配与回收策略"><a href="#6-内存分配与回收策略" class="headerlink" title="6.内存分配与回收策略"></a>6.内存分配与回收策略</h1><p>对象的内存分配，往大方向讲，就是在堆上分配(但也可能经过JIT编译后被拆散为标量类型 并间接地栈上分配)，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲， 将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是 百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存 相关的参数的设置。</p>
<h2 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h2><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将 发起一次Minor GC。</p>
<p>Minor GC和Full GC有什么不一样吗?</p>
<ul>
<li>新生代GC(Minor GC):指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝 生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li>
<li>老年代GC(Major GC &#x2F; Full GC):指发生在老年代的GC，出现了Major GC，经常会伴 随至少一次的Minor GC(但非绝对的，在Parallel Scavenge收集器的收集策略里就有直 接进行Major GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。</li>
</ul>
<h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字 符串以及数组,对象对虚拟机的内存 分配来说就是一个坏消息,经常出现大对象容易导致内存 还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p>
<p>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代 分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。(新生代采用复制算法收集内存)</p>
<h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><p>虚拟机给每个对象定义了一个对象年 龄(Age)计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被 Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15岁)，就将 会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数- XX:MaxTenuringThreshold设置。</p>
<h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了 MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和 大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<h1 id="7-虚拟机性能监控与故障处理工具"><a href="#7-虚拟机性能监控与故障处理工具" class="headerlink" title="7.虚拟机性能监控与故障处理工具"></a>7.虚拟机性能监控与故障处理工具</h1><h2 id="JDK的命令行工具"><a href="#JDK的命令行工具" class="headerlink" title="JDK的命令行工具"></a>JDK的命令行工具</h2><p><a target="_blank" rel="noopener" href="https://my.oschina.net/feichexia/blog/196575">SUN JDK监控和故障处理工具</a>:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>jps</td>
<td>jvm process status tool,显示指定系统内所有的hotspot虚拟机进程</td>
</tr>
<tr>
<td>jstat</td>
<td>jvm statistics monitoring tool,用于收集hotspot虚拟机各方面的运行数据</td>
</tr>
<tr>
<td>jinfo</td>
<td>configuration info for java，显示虚拟机配置信息</td>
</tr>
<tr>
<td>jmap</td>
<td>memory map for java,生成虚拟机的内存转储快照(heapdump文件)</td>
</tr>
<tr>
<td>jhat</td>
<td>jvm heap dump browser，用于分析heapmap文件，它会建立一个http&#x2F;html服务 器让用户可以在浏览器上查看分析结果</td>
</tr>
<tr>
<td>jstack</td>
<td>stack trace for java ,显示虚拟机的线程快照</td>
</tr>
</tbody></table>
<h2 id="HSDIS-JIT生成代码反汇编"><a href="#HSDIS-JIT生成代码反汇编" class="headerlink" title="HSDIS:JIT生成代码反汇编"></a>HSDIS:JIT生成代码反汇编</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/hengyunabc/article/details/26898657">HSDIS</a>是一个Sun官方推荐的HotSpot虚拟机JIT编译代码的反汇编插件，它包含在HotSpot虚 拟机的源码之中。</p>
<h2 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h2><p><a target="_blank" rel="noopener" href="http://www.itzhai.com/jvm-note-automatic-memory-management-mechanism-4.html">JVM笔记 – 自动内存管理机制(调优案例分析与实战)</a><br><a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-rvydxqbv-nc.html">笔记:深入理解JVM 第5章 调优案例分析与实战</a></p>
<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化， 最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。<br>Java 里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。 (OSGi技术)</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>加载( Loading)、 验证( Verification)、 准备( Preparation)、 解析( Resolution)、 初始化( Initialization)、 使用( Using) 和卸载( Unloading) 7 个阶段。<br>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种 顺序按部就班地开始，而解析阶段则不一定:它在某些情况下可以在初始化阶段之后再开 始，这是为了支持 Java 语言的运行时绑定(也称为动态绑定或晚期绑定)。</p>
<p>虚拟机规范则是严格规定了有且只有 5 种情况必须立即对类进行“初始化”(而加载、验证、 准备自然需要在此之前开始):</p>
<ul>
<li>遇到 new、 getstatic、 putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有 进行过初始化，则需要先触发其初始化。</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始 化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类 的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类(包含 main() 方法的那个类)， 虚拟机会先初始化这个主类。</li>
<li>如果一个 java.lang.invoke.MethodHandle 实例 最后的解析结果 REF_getStatic、 REF_putStatic、 REF_invokeStatic 的方法句柄，并且 这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ul>
<p>通过 子类引用父类的静态字段，不会导致子类初始化。是否要触发子类的加载和验证，在虚 拟机规范中并未明确规定，这点取决于虚拟机的具体实现。<br>通过数组定义来引用类，不会触发此类的初始化。比如 SupperClass[] sca &#x3D; new SupperClass[10]; 这里不会初始化SupperClass，但是触发了另外一个名 为“[com.gavin.SuperClass”的类的初始化阶段，它是一个由虚拟机自动生成的，直接继承 于Object的子类，创建动作由字节码指令newarray触发。</p>
<p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不 会触发定义常量类的初始化。比如“private static final CONST&#x3D;”123””,不会引发此类的初始化。<br>当一个类在初始化的时候，要求其父类全部都已经初始化过了，但是一个接口在初始化时，<br>并不要求其父类接口全部完成初始化，只有在真正使用到父接口的时候(如引用接口中定义<br>的常量)才会初始化。</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，虚拟机需要完成以下 3 件事情:</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的 <code>java.lang.Class</code>对象，作为方法区这个类的各种数 据的访问入口。</li>
</ul>
<p>Class文件的获取方式:</p>
<ul>
<li>从 ZIP 包中读取，这很常见，最终成为日后 JAR、 EAR、 WAR 格式的基础。</li>
<li>从网络中获取，这种场景最典型的应用就是 Applet。</li>
<li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 *$Proxy 的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。</li>
<li>数据库中读取</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><p>第一阶段要验证字节流是否符合 Class 文件格式的规范。</p>
<ul>
<li>是否以魔数0xCAFEBABE开头</li>
<li>主、次版本号是否在当前虚拟机处理范围之内。</li>
<li>常量池中的常量中是否有不被支持的常量类型(检查常量tag标志)。</li>
</ul>
<h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要 求。</p>
<h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。由于数据流验证的高复杂性，虚拟机设计团队为了避免过多的时间消耗在字节码验证阶段，在JDK 1.6之后的给方法体的Code属性的 属性表中增加了一项名为” StackMapTable” 的属性,只需要检查StackMapTable属性中的记录 是否合法皆可以了。虚拟机中提供了-XX:-UseSplitVerifier选项来关闭这项优化。</p>
<h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连 接的第三阶段———解析阶段中发生。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>这个阶段进行内存分配的仅包括类变量(被 static 修饰的变量)，而不包括实例变量，实例变 量将会在对象实例化时随着对象一起分配在 Java 堆中。其次，这里所说的初始值“通常情 况”下是数据类型的零值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> value=<span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>value加载类的时候初始化为0，把 value 赋值为 123 的动作将在初始化阶段(方法中)才会执 行。<br>特殊情况:如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值，假设上面类变量 value 的定义变为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> value= <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。除 invokedynamic(虚拟机指令) 指令以外，虚拟机实现可以对第一次解析的结果进行缓存。解析动作主要针对类或接口、字段解析、类方法解析、接口方法解析、方法类型解析、方法 句柄解析和调用点限定符 7 类符号引用进行。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是执行类构造器 <clinit> 方法的过程。</p>
<ol>
<li><clinit> 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static 块)中的语句合并产生</li>
<li>虚拟机保证子类的 <clinit> 方法执行之前，父类的 <clinit> 方法已经执行完毕</li>
<li>对于接口，不能使用static块，但是可以有静态变量的赋值操作。子类接口的 <clinit> 方法调用并不保证父接口的 <clinit> 方法被先调用，只有用到父接口的静态变量的时候，父接口 <clinit> 方法才会被调用。接口的实现类在初始化时也一样不会执行接口的 <clinit> 方法。</li>
<li>虚拟机会保证一个类的 <clinit> 方法在多线程环境中被正确地加锁、同步。如果一个线 程的 <clinit> 方法调用时间过长，就可能造成多个线程阻塞。</li>
</ol>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。 类加载器却在类层次划分、 OSGi、 热部署、代码加密等领域大放异彩。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不 同，那这两个类就必定不相等。每一个类加载器，都拥有一个独立的类空间。</p>
<p>不同的类加载器对 instanceof 关键字运算的结果的影响。除此之外，Class对象的equals方 法、isAssignableFrom方法、isInstance方法的返回结果也会受影响。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从 Java 虚拟机的角度来讲，只存在两种不同的类加载器:一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用 C++ 语言实现[ 1]，是虚拟机自身的一部分;另一种就 是所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继 承自抽象类 java.lang.ClassLoader。<br>绝大部分 Java 程序都会使用到以下 3 种系统提供的类加载器:</p>
<ul>
<li>启动类加载器(Bootstrap ClassLoader):这个类将器负责将存放在 JAVA_HOME\lib 目录中的，或者被-Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的(仅按照 文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载)类库加载 到虚拟机内存中。用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加 载器，那直接使用 null 代替即可。</li>
<li>扩展类加载器(Extension ClassLoader):它负责加载 JAVA_ HOME\lib\ext 目录中的， 或者被 java.ext.dirs 系统变量所指定的路径中的所有类库。</li>
<li>应用程序类加载器(Application ClassLoader):由于这个类加载器是 ClassLoader 中 的 getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器。它负责加 载用户类路径( ClassPath) 上所指定的类库。如果应用程序中没有自定义过自己的类 加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载 器。这里类加载器之间的父子关系一般不会以继承( Inheritance) 的关系来实现，而是都使 用组合( Composition) 关系来复用父加载器的代码。</p>
<p>一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请<br>求委派给父类加载器去完成。</p>
<p>类 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委 派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中 都是同一个类。</p>
<p><code>rt.jar</code>包中部分源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)   <span class="keyword">throws</span> ClassNotFoundException&#123;  </span><br><span class="line">    <span class="comment">// First, check if the class has already been loaded  </span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);  </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;  </span><br><span class="line">                c = parent.loadClass(name, <span class="literal">false</span>);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                c = findBootstrapClassOrNull(name);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;  </span><br><span class="line">            <span class="comment">// ClassNotFoundException thrown if class not found  </span></span><br><span class="line">            <span class="comment">// from the non-null parent class loader  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// If still not found, then invoke findClass in order  </span></span><br><span class="line">            <span class="comment">// to find the class.  </span></span><br><span class="line">            c = findClass(name);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;  </span><br><span class="line">        resolveClass(c);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> c;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>双亲委派模型是通过loadClass()方法来实现的，根据代码以及代码中的注释可以很清楚地了解整个过程其实非常简单：先检查是否已经被加载过，如果没有则调用父加载器的loadClass()方法，如果父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，则先抛出ClassNotFoundException，然后再调用自己的findClass()方法进行加载。</p>
<h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前————即 JDK 1.2 发布之 前。<br>JDK 1.2 之后已不提倡用户再去覆盖 loadClass() 方法，而应当把自己的类加载逻辑写到 findClass() 方法中，在 loadClass() 方法的逻辑里如果父类加载失败，则会调用自己的 findClass() 方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。<br>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的。如果基础类又要调用回用 户的代码，那该怎么办?<br>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计:线程上下文类加载器( Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的 setContextClassLoader方法进行设置，如果创建线程时还未设置，它将会从父线程中继承 一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认是应用类加载 器。<br>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。<br><a target="_blank" rel="noopener" href="https://www.osgi.org/developer/">OSGi</a> 实现模块化热部署的关键则是它自定义的<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#minor1.1">类加载器机制</a>的实现。每一个程序模块( OSGi 中称为 Bundle) 都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再是双亲委派模 型中的树状结构，而是进一步发展为更加复杂的网状结构。</p>
<h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而虚拟机的执<br>行引擎则是由自己实现的，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行<br>那些不被硬件直接支持的指令集格式。<a target="_blank" rel="noopener" href="http://blog.csdn.net/dd864140130/article/details/49515403">关于虚拟机字节码执行引擎</a></p>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从<br>调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。<br>对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧。<br><img src="https://d2ffutrenqvap3.cloudfront.net/items/403v1R1R05293g2v3C36/QQ20171225-112610.png?v=90f94eb9"></p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>编译的时候，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变 量表的最大容量。</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈也常被称为操作栈，它是一个后入先出栈。操作数栈的最大深 度也是编译的时候被写入到方法表的Code属性的max_stacks数据项中。</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支 持方法调用过程中的动态连接。</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法 返回的字节码指令。<br>另外一种退出方式是，在方法执行过程中遇到了异常。</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>在Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用 在Class文件里存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址(相当 于直接引用)。</p>
<h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p>Java虚拟机里提供了5条方法调用字节码指令，分别是:</p>
<ul>
<li>nvokestatic:调用静态方法</li>
<li>invokespecial:调用实例构造器方法，私有方法和父类方法。</li>
<li>invokevirtual:调用虚方法。</li>
<li>invokeinterface:调用接口方法，会在运行时再确定一个实现此接口的对象。</li>
<li>invokedynamic:先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法， 在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令 的分派逻辑是由用户所设定的引导方法决定的。</li>
</ul>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p>依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。静态分派的最典型应 用就是方法重载。静态分派发生在编译阶段，因此确定静态分派的动力实际上不是由虚拟机 来执行的。</p>
<h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>动态分派与重写(Override)有着很密切的关联。如下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.xtayfjpk.jvm.chapter8;</span><br><span class="line">public class DynamicDispatch &#123;</span><br><span class="line">    static abstract class Human &#123;</span><br><span class="line">        protected abstract void sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">    static class Man extends Human &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void sayHello() &#123;</span><br><span class="line">            System.out.println(&quot;man say hello&quot;);</span><br><span class="line">&#125; &#125;</span><br><span class="line">    static class Woman extends Human &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void sayHello() &#123;</span><br><span class="line">            System.out.println(&quot;woman say hello&quot;);</span><br><span class="line">&#125; &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Human man = new Man();</span><br><span class="line">        Human woman = new Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man = new Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>这里显示不可能是根据静态类型来决定的，因为静态类型都是Human的两个变量man和 woman在调用sayHello()方法时执行了不同的行为，并且变量man在两次调用中执行了不同的 方法。导致这个现象的原是是这两个变量的实际类型不同。那么Java虚拟机是如何根据实际 类型来分派方法执行版本的呢，我们使用javap命令输出这段代码的字节码，结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=3, args_size=1</span><br><span class="line">       0: new           #16</span><br><span class="line">Dispatch$Man</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #18</span><br><span class="line">cDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">7: astore_1</span><br><span class="line">       8: new           #19</span><br><span class="line">Dispatch$Woman</span><br><span class="line">11: dup</span><br><span class="line">      12: invokespecial #21</span><br><span class="line">cDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      15: astore_2</span><br><span class="line">      16: aload_1</span><br><span class="line">      17: invokevirtual #22</span><br><span class="line">cDispatch$Human.sayHello:()V</span><br><span class="line">      20: aload_2</span><br><span class="line">      21: invokevirtual #22</span><br><span class="line">cDispatch$Human.sayHello:()V</span><br><span class="line">      24: new           #19</span><br><span class="line">Dispatch$Woman</span><br><span class="line">27: dup</span><br><span class="line">      28: invokespecial #21</span><br><span class="line">cDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      31: astore_1</span><br><span class="line">      32: aload_1</span><br><span class="line">      33: invokevirtual #22</span><br><span class="line">cDispatch$Human.sayHello:()V</span><br><span class="line">      36: return</span><br></pre></td></tr></table></figure>
<p>0-15行的字节码是准备动作，作用是建立man和woman的内存空间，调用Man和Woman类的 实例构造器，将这两个实例的引用存放在第1和第2个局部变量表Slot之中，这个动作对应了代 码中这两句:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Human man = new Man();</span><br><span class="line">Human woman = new Woman();</span><br></pre></td></tr></table></figure>
<p>接下来的第16-21行是关键部分，第16和第20两行分别把刚刚创建的两个对象的引用压到栈 顶，这两个对象是将执行的sayHello()方法的所有者，称为接收者(Receiver)，第17和第21两 行是方法调用指令，单从字节码的角度来看，这两条调用指令无论是指令(都是invokevirtual) 还是参数(都是常量池中Human.sayHello()的符号引用)都完全一样，但是这两条指令最终执行 的目标方法并不相同，其原因需要从invokevirutal指令的多态查找过程开始说起， invokevirtual指令的运行时解析过程大致分为以下步骤:</p>
<ul>
<li>a.找到操作数栈顶的第一个元素所指向的对象实际类型，记作C。</li>
<li>b.如果在类型C中找到与常量中描述符和简单名称都相同的方法，则进行访问权限校验， 如果通过则返回这个方法的直接引用，查找结束;不通过则返回 java.lang.IllegalAccessError错误。</li>
<li>c.否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索与校验过程。</li>
<li>d.如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError错误。</li>
</ul>
<p>由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用 中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过 程就是Java语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版 本的分派过程称为动态分派。</p>
<h4 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h4><p>ava语言的动态分派属于单分派类型。所在Java 语言是一门静态多分派，动态单分派语言。</p>
<h3 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h3><p>由于动态分派是非常频繁的动作，最常用的优化手段就是在类的方法区中建 立一个虚方法表(Virtual Method Table，也称vtable，与此对应，在invokeinterface执行时 也会用到接口方法表，Interface Method Table，也称itable)，使用虚方法表索引来代替元数 据据查找以提高性能。<br>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那么子类<br>的虚方法表里面的地址入口和父类方法的地址入口是一致的，都指向父类的实现入口。如果<br>子类中重写了这个方法，子类方法表中的地址将会被替换为指向子类实现版本的地址入口。</p>
<h3 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h3><p>DK 7 的发布，字节码指令集终于迎来了第一位新成员—— invokedynamic 指令</p>
<h4 id="动态类型语言"><a href="#动态类型语言" class="headerlink" title="动态类型语言"></a>动态类型语言</h4><p>动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期。 “变量无类型而变量值才有类型”这个特点也是动态类型语言的一个重要特征。</p>
<h3 id="JDK-1-7-与动态类型"><a href="#JDK-1-7-与动态类型" class="headerlink" title="JDK 1.7 与动态类型"></a>JDK 1.7 与动态类型</h3><h4 id="java-lang-invoke-包"><a href="#java-lang-invoke-包" class="headerlink" title="java.lang.invoke 包"></a>java.lang.invoke 包</h4><p>JDK 1.7 实现了 JSR-292， 新加入的 java.lang.invoke 包就是 JSR-292 的一个重要组成部 分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MethodHandleTest &#123;</span><br><span class="line">	static class ClassA&#123;</span><br><span class="line">		public void println(String s)&#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125; &#125;</span><br><span class="line">		public static void main(String[] args) throws Throwable &#123;</span><br><span class="line">			Object obj = System.currentTimeMillis() % 2 == 0 ? System.out:new ClassA(); </span><br><span class="line">			/* 无论obj最终是那个实现类，下面这句都能正确调用到println方法 */ </span><br><span class="line">			getPrintlnMH(obj).invokeExact(&quot;icyfenix&quot;);</span><br><span class="line">			/* output:</span><br><span class="line">			* icyfenix</span><br><span class="line">			*/ </span><br><span class="line">		&#125;</span><br><span class="line">	private static MethodHandle getPrintlnMH(Object receiver) throws Throwable&#123; /* MethodType: 代表“方法类型”，包含了方法的返回值(methodType()的第一个参数)</span><br><span class="line">		* 和具体参数(methodType()第二个及以后的参数) */</span><br><span class="line">		MethodType mt = MethodType.methodType(void.class, String.class); /* lookup()方法来自于MethodHandles.lookup，</span><br><span class="line">		* 这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄。</span><br><span class="line">		* 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者， * 也即是this指向的对象，这个参数以前是放在参数列表中进行传递的，而现在提供给了bindTo()方法来</span><br><span class="line">		完成这件事情 */</span><br><span class="line">		return MethodHandles.lookup().findVirtual(receiver.getClass(), &quot;println&quot;, mt)</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MethodHandle 的使用方法和效果与 Reflection 有众多相似之处，不过，它们还是有以下这些 区别:</p>
<ul>
<li>Reflection 是在模拟 Java 代码层次的方法调用，而 MethodHandle 是在模拟字节码层次 的方法调用。</li>
<li>Reflection 是重量级，而 MethodHandle 是轻量级。</li>
</ul>
<h4 id="invokedynamic-指令"><a href="#invokedynamic-指令" class="headerlink" title="invokedynamic 指令"></a>invokedynamic 指令</h4><p>在某种程度上， invokedynamic 指令与 MethodHandle 机制的作用是一样的，都是为了解决 原有 4 条” invoke*” 指令方法分派规则固化在虚拟机之中的问题，把如何查找目标方法的决定 权从虚拟机转嫁到具体用户代码之中。</p>
<h3 id="掌控方法分派规则"><a href="#掌控方法分派规则" class="headerlink" title="掌控方法分派规则"></a>掌控方法分派规则</h3><p>invokedynamic 指令与前面 4 条” invoke*” 指令的最大差别就是它的分派逻辑不是由虚拟机决 定的，而是由程序员决定。<br>可以通过” super” 关键字很方便地调用到父类中的方法，但如果要访问祖类的方法呢? 使用 MethodHandle 来解决相关问题.</p>
<h1 id="基于栈的字节码解析执行引擎"><a href="#基于栈的字节码解析执行引擎" class="headerlink" title="基于栈的字节码解析执行引擎"></a>基于栈的字节码解析执行引擎</h1><h2 id="解析执行"><a href="#解析执行" class="headerlink" title="解析执行"></a>解析执行</h2><p>Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历 语法树生成线性的字节码指令流的过程。因为这一部分动作是在 Java 虚拟机之外进行的，而 解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现。</p>
<h2 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h2><p>Java 编译器输出的指令流，基本上是一种基于栈的指令集架构。<br>基于栈的指令集主要的优点就是可移植，寄存器由硬件直接提供，程序直接依赖这些硬件寄<br>存器则不可避免地要受到硬件的约束。<br>栈架构指令集的主要缺点是执行速度相对来说会稍慢一些。<br>虽然栈架构指令集的代码非常紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构<br>多，因为出栈、入栈操作本身就产生了相当多的指令数量。更重要的是，栈实现在内存之<br>中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的<br>瓶颈。尽管虚拟机可以采取栈顶缓存的手段，把最常用的操作映射到寄存器中避免直接内存<br>访问，但这也只能是优化措施而不是解决本质问题的方法。由于指令数量和内存访问的原<br>因，所以导致了栈架构指令集的执行速度会相对较慢。</p>
<h2 id="基于栈的解析执行过程"><a href="#基于栈的解析执行过程" class="headerlink" title="基于栈的解析执行过程"></a>基于栈的解析执行过程</h2><p>在 HotSpot 虚拟机中，有很多以” fast_” 开头的非标准字节码指令用于合并、替换输入的字节 码以提升解释执行性能，而即时编译器的优化手段更加花样繁多。</p>
<p><a target="_blank" rel="noopener" href="http://www.itzhai.com/jvm-executive-subsystem-bytecode-interpreter.html#read-more">JVM笔记–虚拟机执行子系统</a></p>
<h1 id="类加载及执行子系统的案例与实战"><a href="#类加载及执行子系统的案例与实战" class="headerlink" title="类加载及执行子系统的案例与实战"></a>类加载及执行子系统的案例与实战</h1><h2 id="Tomcat-正统的类加载器架构"><a href="#Tomcat-正统的类加载器架构" class="headerlink" title="Tomcat:正统的类加载器架构"></a>Tomcat:正统的类加载器架构</h2><p>个功能健全的 Web 服务器，要解决如下几个问题:</p>
<ul>
<li>部署在同一个服务器上的两个 Web 应用程序所使用的 Java 类库可以实现相互隔离。</li>
<li>部署在同一个服务器上的两个 Web 应用程序所使用的 Java 类库可以互相共享。</li>
<li>服务器需要尽可能地保证自身的安全不受部署的 Web 应用程序影响。</li>
<li>支持 JSP 应用的 Web 服务器，大多数都需要支持 HotSwap 功能。</li>
</ul>
<p>在 Tomcat 目录结构中，有 3 组目录(“ &#x2F;common&#x2F;* “、” &#x2F;server&#x2F;* “ 和” &#x2F;shared&#x2F;* “) 可以存 放 Java 类库，另外还可以加上 Web 应用程序自身的目录” &#x2F;WEB-INF&#x2F;* “，一共 4 组。</p>
<h3 id="Tomcat热部署原理"><a href="#Tomcat热部署原理" class="headerlink" title="Tomcat热部署原理:"></a>Tomcat热部署原理:</h3><p><img src="https://d2ffutrenqvap3.cloudfront.net/items/1U1v1Y1A0H3E2l3W112O/QQ20180105-104820@2x.png?v=d76cf834"><br>JasperLoader的加载范围仅仅是这个 JSP 文件所编译出来的那一个 Class， 它出现的目的就 是为了被丢弃:当服务器检测到 JSP 文件被修改时，会替换掉目前的 JasperLoader 的实 例，并通过再建立一个新的 Jsp 类加载器来实现 JSP 文件的 HotSwap 功能。</p>
<h1 id="OSGi-灵活的类加载器架构"><a href="#OSGi-灵活的类加载器架构" class="headerlink" title="OSGi:灵活的类加载器架构"></a>OSGi:灵活的类加载器架构</h1><p>Java社区有这样一句话:“学习JEE规范，去看JBoss源码;学习类加载器，就去看OSGi源 码”。<br>OSGi技术常用模块化的热加载.例如一个web网站,需要热部署购物车模块等</p>
<h1 id="字节码生成技术与动态代理的实现"><a href="#字节码生成技术与动态代理的实现" class="headerlink" title="字节码生成技术与动态代理的实现"></a>字节码生成技术与动态代理的实现</h1><p>javac 也是一个由 Java 语言写成的程序，它的代码存放在 OpenJDK 的 <code>langtools/src/share/classes/com/sun/tools/javac</code> 目录中。 要深入了解字节码生成，阅读 javac 的源码是个很好的途径。<br>动态代理实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类与 原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中。调用了 sun.misc.ProxyGenerator.generateProxyClass()方法来完成生成字节码的动作，这个方法可 以在运行时产生一个描述代理类的字节码 byte[]数组</p>
<h1 id="早期-编译期-优化"><a href="#早期-编译期-优化" class="headerlink" title="早期(编译期)优化"></a>早期(编译期)优化</h1><p>Java语言的“编译期”是一段不确定的操作过程，可能是:</p>
<ul>
<li>前端编译器(编译器的前端)把Java文件转换为class文件;Sun 的 Javac、 Eclipse JDT 中的增量式编译器( ECJ)。</li>
<li>后端编译器(JIT编译期 Just in time compiler)把字节码变成机器码;JIT 编译器: HotSpot VM 的 C1、 C2 编译器。</li>
<li>静态编译器(AOT编译器 ahead of time compiler)直接把Java编译成本地机器代码;</li>
<li>AOT 编译器: GNU Compiler for the Java(GCJ)、Excelsior JET。</li>
</ul>
<p>参考 <a href="http://www.antwhy.com/2017/11/12/javac%20compiler-basis/">Javac编译器</a></p>
<h1 id="晚期-运行期-优化"><a href="#晚期-运行期-优化" class="headerlink" title="晚期(运行期)优化"></a>晚期(运行期)优化</h1><h2 id="HotSpot虚拟机内的即时编译器"><a href="#HotSpot虚拟机内的即时编译器" class="headerlink" title="HotSpot虚拟机内的即时编译器"></a>HotSpot虚拟机内的即时编译器</h2><h3 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h3><p>HotSpot 虚拟机中内置了两个即时编译器，分别称为 Client Compiler 和 Server Compiler。<br>HotSpot 虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用”- client” 或”-server” 参数去强制指定虚拟机运行在 Client 模式或 Server 模式。<br>为了在程序启动响应速度与运行效率之间达到最佳平衡， HotSpot 虚拟机还会逐渐启用分层 编译( Tiered Compilation) 的策略。<br>实施分层编译后， Client Compiler 和 Server Compiler 将会同时工作，许多代码都可能会被 多次编译，用 Client Compiler 获取更高的编译速度，用 Server Compiler 来获取更好的编译 质量，在解释执行的时候也无须再承担收集性能监控信息的任务。 </p>
<h3 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h3><p>“热点代码”有两类，即:被多次调用的方法。被多次执行的循环体。<br>判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为热点探测。<br>目前主要的热点探测判定方式有两种:基于采样的热点探测，基于计数器的热点探测。<br>在 HotSpot 虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准 备了两类计数器:方法调用计数器( Invocation Counter) 和回边计数器( Back Edge Counter)。<br>当计数器超过阈值溢出了，就会触发 JIT 编译。<br>当编译工作完成之后，这个方法的调用入口地址就会被系统自动改写成新的。<br>使用虚拟机参数-XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对 次数。<br>回边计数器，它的作用是统计一个方法中循环体代码执行的次数。</p>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>在默认设置下，无论是方法调用产生的即时编译请求，还是 OSR 编译请求，虚拟机在代码编 译器还未完成之前，都仍然将按照解释方式继续执行，而编译动作则在后台的编译线程中进 行。<br>用户可以通过参数-XX:-BackgroundCompilation 来禁止后台编译。 </p>
<h3 id="查看及分析即时编译结果"><a href="#查看及分析即时编译结果" class="headerlink" title="查看及分析即时编译结果"></a>查看及分析即时编译结果</h3><p>参数-XX：+PrintCompilation要求虚拟机在即时编译时将被编译成本地代码的方法名称打印出来<br>%的输出说明是由回边计数器触发的OSR编译；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM</span> <span class="operator">=</span> <span class="number">15000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">doubleValue</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">// 这个空循环用于后面演示JIT代码优化过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">100000</span>; j++);</span><br><span class="line">        <span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">calcSum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += doubleValue(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NUM; i++) &#123;</span><br><span class="line">            calcSum();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">darcy<span class="meta">@darcy</span>-pc:~/IdeaProjects/jvm_in_action/src$ javac  ch11/Test.java </span><br><span class="line">darcy<span class="meta">@darcy</span>-pc:~/IdeaProjects/jvm_in_action/src$ java -XX:+PrintCompilation ch11.Test</span><br><span class="line">     <span class="number">77</span>    <span class="number">1</span>       <span class="number">3</span>       java.lang.String::hashCode (<span class="number">55</span> bytes)</span><br><span class="line">     <span class="number">77</span>    <span class="number">2</span>       <span class="number">3</span>       java.lang.String::equals (<span class="number">81</span> bytes)</span><br><span class="line">     <span class="number">79</span>    <span class="number">3</span>       <span class="number">3</span>       java.lang.String::charAt (<span class="number">29</span> bytes)</span><br><span class="line">     <span class="number">79</span>    <span class="number">4</span>       <span class="number">3</span>       java.lang.String::length (<span class="number">6</span> bytes)</span><br><span class="line">     <span class="number">81</span>    <span class="number">6</span>       <span class="number">3</span>       java.lang.Object::&lt;init&gt; (<span class="number">1</span> bytes)</span><br><span class="line">     <span class="number">81</span>    <span class="number">5</span>       <span class="number">1</span>       java.lang.ref.Reference::get (<span class="number">5</span> bytes)</span><br><span class="line">     <span class="number">83</span>    <span class="number">8</span>     n <span class="number">0</span>       java.lang.System::arraycopy (<span class="keyword">native</span>)   (<span class="keyword">static</span>)</span><br><span class="line">     <span class="number">83</span>    <span class="number">7</span>       <span class="number">3</span>       java.lang.String::indexOf (<span class="number">70</span> bytes)</span><br><span class="line">     <span class="number">83</span>   <span class="number">11</span>       <span class="number">3</span>       java.lang.Math::min (<span class="number">11</span> bytes)</span><br><span class="line">     <span class="number">83</span>    <span class="number">9</span>       <span class="number">3</span>       java.lang.AbstractStringBuilder::ensureCapacityInternal (<span class="number">27</span> bytes)</span><br><span class="line">     <span class="number">84</span>   <span class="number">10</span>       <span class="number">3</span>       java.util.Arrays::copyOfRange (<span class="number">63</span> bytes)</span><br><span class="line">     <span class="number">85</span>   <span class="number">12</span>       <span class="number">1</span>       java.lang.ThreadLocal::access$<span class="number">400</span> (<span class="number">5</span> bytes)</span><br><span class="line">     <span class="number">85</span>   <span class="number">13</span>       <span class="number">3</span>       java.lang.AbstractStringBuilder::append (<span class="number">50</span> bytes)</span><br><span class="line">    <span class="number">118</span>   <span class="number">14</span> %     <span class="number">3</span>       ch11.Test::doubleValue @ <span class="number">2</span> (<span class="number">18</span> bytes)</span><br><span class="line">    <span class="number">119</span>   <span class="number">15</span>       <span class="number">3</span>       ch11.Test::doubleValue (<span class="number">18</span> bytes)</span><br><span class="line">    <span class="number">119</span>   <span class="number">16</span> %     <span class="number">4</span>       ch11.Test::doubleValue @ <span class="number">2</span> (<span class="number">18</span> bytes)</span><br><span class="line">    <span class="number">120</span>   <span class="number">14</span> %     <span class="number">3</span>       ch11.Test::doubleValue @ -<span class="number">2</span> (<span class="number">18</span> bytes)   made not entrant</span><br><span class="line">    <span class="number">120</span>   <span class="number">17</span>       <span class="number">4</span>       ch11.Test::doubleValue (<span class="number">18</span> bytes)</span><br><span class="line">    <span class="number">121</span>   <span class="number">15</span>       <span class="number">3</span>       ch11.Test::doubleValue (<span class="number">18</span> bytes)   made not entrant</span><br><span class="line">    <span class="number">121</span>   <span class="number">18</span>       <span class="number">3</span>       ch11.Test::calcSum (<span class="number">26</span> bytes)</span><br><span class="line">    <span class="number">122</span>   <span class="number">19</span> %     <span class="number">4</span>       ch11.Test::calcSum @ <span class="number">4</span> (<span class="number">26</span> bytes)</span><br><span class="line">    <span class="number">124</span>   <span class="number">20</span>       <span class="number">4</span>       ch11.Test::calcSum (<span class="number">26</span> bytes)</span><br><span class="line">    <span class="number">126</span>   <span class="number">18</span>       <span class="number">3</span>       ch11.Test::calcSum (<span class="number">26</span> bytes)   made not entrant</span><br></pre></td></tr></table></figure>
<h2 id="编译优化技术"><a href="#编译优化技术" class="headerlink" title="编译优化技术"></a>编译优化技术</h2><ol>
<li>公共子表达式消除</li>
<li>数组边界检查消除</li>
<li>方法内联</li>
<li>逃逸分析</li>
</ol>
<h1 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h1><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内 存和从内存中取出变量值这样的底层细节。<br>Java内存模型规定了所有的变量都存储在主内存(Main Memory)中。每条线程还有自己的工作 内存(Working Memory)，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷 贝，线程对变量的所有操作(读取，赋值等)都必须是工作内存中进行，而不能直接读写主内存 中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均 需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下图:<br><img src="https://d2ffutrenqvap3.cloudfront.net/items/0m0s3M3x3L29062t2W0M/QQ20180110-161349@2x.png?v=bad00902"></p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存之类的实现细节， Java内存模型中定义了以下8种操作来完成。这8种操作都是原子性的、不可再分的(对 double和Long类型除外)。</p>
<h3 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h3><p>Java内存模型是围绕着并发过程中如何处理原子性、可见性、有序性这三个特征来建立的。</p>
<h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><ol>
<li>程序次序规则(PragramOrderRule):在一个线程内，按照程序代码顺序，书写在前面的 操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序， 因为要考虑分支、循环结构。</li>
<li>管程锁定规则(MonitorLockRule):一个unlock操作先行发生于后面对同一个锁的lock操 作。这里必须强调的是同一个锁，而”后面“是指时间上的先后顺序。</li>
<li>volatile变量规则(VolatileVariableRule):对一个volatile变量的写操作先行发生于后面对 这个变量的读取操作，这里的”后面“同样指时间上的先后顺序。</li>
<li>线程启动规则(ThreadStartRule):Thread对象的start()方法先行发生于此线程的每一个 动作。</li>
<li>线程终止规则(ThreadTerminationRule):线程中的所有操作都先行发生于对此线程的终 止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值等作段检测到线 程已经终止执行。</li>
<li>线程中断规则(ThreadInterruptionRule):对线程interrupt()方法的调用先行发生于被中断 线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生。</li>
<li>对象终结规则(FinalizerRule):一个对象初始化完成(构造方法执行完成)先行发生于它的finalize()方法的开始。</li>
<li>传递性(Transitivity):如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.antwhy.com/2016/06/27/2.0.English-Extremely-simple-syntax/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AntWhy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/27/2.0.English-Extremely-simple-syntax/" itemprop="url">英语 - 语法篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-06-27T20:59:00+08:00">
                2016-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="NO-1-综述"><a href="#NO-1-综述" class="headerlink" title="NO.1 综述"></a>NO.1 综述</h1><h2 id="语法是什么"><a href="#语法是什么" class="headerlink" title="语法是什么"></a>语法是什么</h2><p>我们读的每一篇文章,说的每一句话,都是有一个个的小单元构成的,我们把这些小单元叫做<span style="color:#6A5ACD;font-size:16px">单词</span>。每一个单词都有自己的意思,<span style="color:#1C1C1C;font-size:17px"> i </span>是 我 的意思,<span style="color:#1C1C1C;font-size:17px"> like </span>是 喜欢 的意思,<span style="color:#1C1C1C;font-size:17px"> banana </span>是 香蕉 的意思。有时候一个简单的意思,我们用一个单词就能表达清楚。但很多时候,我们想表达复杂的思想是,就得动用多个单词。比如你想表达 我喜欢香蕉 ,如果你还是一个婴儿,给你三个单词,<span style="color:#1C1C1C;font-size:17px"> like i banana </span>,让你组合成想表达的意思,你可能不会。但是你现在长大了,你知道了<span style="color:#1C1C1C;font-size:17px"> i like banana </span>来表达 我喜欢香蕉 ,为了表示 你喜欢的是香蕉这种水果,你可能会 banana 加上复数,<span style="color:#1C1C1C;font-size:17px"> i like bananas </span>,或者为了表达你过去喜欢水果,你可能会把like改成过去式<span style="color:#1C1C1C;font-size:17px"> i liked bananas </span>,从婴儿时期的只知道单词的意思,到现在能按照正确的顺序,把单词排列成句子,这就是语法。所以什么是语法:<span style="color:#F00;font-size:16px">语法就是把单词的正确形式,按正确顺序排列成句子的法规。</span><br>这句话中,有两个重要的观点,1.单词的正确形式,叫做词法。2.排序正确的句子,叫做句法。</p>
<p><span style="color:#00FFFF;font-size:16px">单词的正确形式</span>–词法: 名称、冠词、动词、形容词、副词、代词、介词、连词、数词<br><span style="color:#00FFFF;font-size:16px">句子的正确排序</span>–句法: 从句、并列句、复合句、疑问句、否定句</p>
<p>大部分老师在教语法的时候,把重点搞错了,大部分英语老师都是在讲单独的语法规则,然后通过大量刷题让你死记硬背,却忽视了语法规则背后的逻辑关系和一些核心概念的建立,通过刷题和记住概念的语法是能应付考试,而且考完马上就忘。而通过建立核心概念,通过核心概念一步步分叉学习出来的语法,不但记得牢,记得久,帮你轻松应对英语考试,还能正在帮你提升底层的英语技术,为你的阅读、写作、口语、演讲能力打下坚实的基础。</p>
<h2 id="语法的核心概念是什么"><a href="#语法的核心概念是什么" class="headerlink" title="语法的核心概念是什么"></a>语法的核心概念是什么</h2><p>语法的核心概念就像五大公理在欧几里得几何学中地位一样,基于五大公理构造了初高中让我们挠破头的几何学,比如过相异两点，能作且只能作一直线,这种看起来显而易见的结论,就是公理。英语中也有类似的公理,只要你熟悉了这个公理,学会了核心概念,你才能将语法学习下去。语法学习的核心概念是?</br><br><span style="color:#F00;font-size:16px">五大基本句型</span></p>
<ul>
<li>主谓(SV): I remember</li>
<li>主谓宾(SVO): I love you</li>
<li>主谓宾宾(SVOO): I told you a story <strong>&#x2F;</strong> Lilei just gave me a correct answer</li>
<li>主谓宾宾补(SVOC): The story made you happy <strong>&#x2F;</strong> I find English easy</li>
<li>主系表(SVC): You are beautiful <strong>&#x2F;</strong> you look beautiful <strong>&#x2F;</strong> you are a beauty</li>
</ul>
<p>1.S&#x3D;subject 主语 2.V&#x3D;verb 谓语动词 3.O&#x3D;object 宾语 4.C&#x3D;complement 补语(表语)</p>
<p>记住了这5大基本句型,就基本拿到了打开语法大门的钥匙,后面无论多复杂的句型,都是从这几个句型演化出来的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.antwhy.com/2016/05/30/1.3.English-word/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AntWhy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/30/1.3.English-word/" itemprop="url">英语 -- 单词篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-30T11:05:12+08:00">
                2016-05-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x01-背单词的三重境界"><a href="#0x01-背单词的三重境界" class="headerlink" title="0x01.背单词的三重境界 "></a><span style="color:#436EEE;font-size:24px">0x01.背单词的三重境界 </span></h1><h2 id="市面上英语学习方法"><a href="#市面上英语学习方法" class="headerlink" title="市面上英语学习方法"></a>市面上英语学习方法</h2><p><span style="color:#F00;font-size:16px"><strong>1.词根词缀法</strong></span><br>方式: 把单词拆成偏旁部首来记忆<br>缺点: 适合用词根词缀记忆的词不足10%</p>
<p><span style="color:#F00;font-size:16px"><strong>2.联想记忆法</strong></span><br>方式: 通过汉子谐音来记单词<br>例: pregnant(怀孕的) ,汉语谐音: 扑来个男的<br>ambition (野心) , 汉语谐音: 俺必胜<br>charisma (领袖气质) , cha-&gt;china, ris-rise, ma-&gt;mao, 中国升起了毛泽东,毛泽东是伟大领袖,所有charisma是领袖气质<br>缺点: 联想的方向不确定, 适合联想记忆的词很少</p>
<p><span style="color:#F00;font-size:16px"><strong>3.死记硬背法</strong></span><br>方式: 重复记忆<br>缺点: 无聊,很难坚持</p>
<h2 id="背单词的三重境界"><a href="#背单词的三重境界" class="headerlink" title="背单词的三重境界"></a>背单词的三重境界</h2><p><span style="color:#F00;font-size:16px"><strong>第一重:重复记忆法</strong></span><br>通过死记硬背,重复记忆基础词,只知道单词的表面意思,能读懂文章,没办法运用<br>例:impotent , 虚弱的,偏向于懦弱无能, 不能用在生病虚弱, impotent还有衍生意思, “阳痿的”</p>
<p><span style="color:#F00;font-size:16px"><strong>第二重:精通词义境界</strong></span><br><strong>通过词根,词缀,词源,联想法,精通知晓单词的源头含义</strong></p>
<p>例如: impotent &#x3D; 前缀 im + 词根 potent<br>im 是否定前缀, 表示不怎么样<br>词根 potent 在拉丁语中的意思是有能力的, 相当于powerful, 如potential(潜力)<br>所以 impotent否定了potent就变成了 无能的, impotent</p>
<p><span style="color:#F00;font-size:16px"><strong>第三重:环境记忆境界</strong></span><br>通过具体的语境,深刻记住一个词是怎么被用出来的<br>片段原文:<br>Monica: What would you do if you were omnipotent?<br>Joey: Probably kill myself.<br>Monica: Excuse me?<br>Joey: Hey, if little Joey’s dead, then I got on reason to live!<br>Roess: Joey, uh-OMnipotent.<br>Joey: You are? Ross, i’m sorry…</p>
<p>关键点: omnipotent vs impotent<br>omni-(万能的) + potent (有能力的) &#x3D; omnipotent (无所不能的)<br>im-(否定前缀) + potent (有能力的) &#x3D; impotent (无能的,阳痿的)</p>
<h1 id="0x02-重复记忆法-艾宾浩斯曲线"><a href="#0x02-重复记忆法-艾宾浩斯曲线" class="headerlink" title="0x02.重复记忆法:艾宾浩斯曲线 "></a><span style="color:#436EEE;font-size:24px">0x02.重复记忆法:艾宾浩斯曲线 </span></h1><h2 id="一-艾宾浩斯记忆曲线"><a href="#一-艾宾浩斯记忆曲线" class="headerlink" title="一.艾宾浩斯记忆曲线"></a>一.艾宾浩斯记忆曲线</h2><p>其实是<span style="color:#7CFC00;font-size:16px">艾宾浩斯遗忘曲线(The Ebbinghaus Forgetting Curve)</span>,它并没有给出记忆的最佳途径,用单词书背词,和用背词app背词,没有本质区别</p>
<p>主要目标: 想尽一切办法, 把背单词这件事, 持续做下去</p>
<h2 id="二-让自己爽-持续做下去的3条锦囊"><a href="#二-让自己爽-持续做下去的3条锦囊" class="headerlink" title="二.让自己爽,持续做下去的3条锦囊"></a>二.让自己爽,持续做下去的3条锦囊</h2><p><span style="color:#F00;font-size:16px"><strong>1.降低心理预期</strong></span><br>每天背50次: 可以轻松完成<br>每天背100次: 有些挑战,但仍然可以完成<br>每天背150次: 一个人每天记忆的极限</p>
<p>it’s marathon, not a sprint<br>背单词是个马拉松,不是短跑</p>
<p><span style="color:#F00;font-size:16px"><strong>2.找个背单词伙伴</strong></span><br>找一个和你水平差不多的背单词伙伴,一起学习课程,并且完成每次的背单词作业</p>
<p>you are not a procratinator, you are just lonely.<br>哪有什么拖延,你就是孤独罢了.</p>
<p><span style="color:#F00;font-size:16px"><strong>3.在短时间里,猛记单词</strong></span><br>在能承受的范围内,每天尽可能多背单词 (比如, 150个)</p>
<h2 id="三-背单词的具体操作手法"><a href="#三-背单词的具体操作手法" class="headerlink" title="三.背单词的具体操作手法"></a>三.背单词的具体操作手法</h2><p><span style="color:#F00;font-size:16px"><strong>1.背什么单词</strong></span><br>有考试需求的: 只背考试单词<br>没有考试需求的, 但基础很差的, 背朗文定义词汇表(2000个词)<br>本身英语水平不错的, 四六级&#x2F;雅思&#x2F;托福&#x2F;gre单词</p>
<p><span style="color:#F00;font-size:16px"><strong>2.怎么背单词</strong></span><br>用单词app: 按照每天的提醒背诵</p>
<p>用单词书<br>(1)自己定制计划<br>(2)把认识的词用笔划掉<br>(3)当日任务<br>第一遍, 中英对照过一遍<br>第二遍, 以20个词为一个小组, 看英文单词, 说出中文意思<br>第三部, 分组辩词结束后, 把词从头到尾过一遍<br>(4)第二天任务<br>只复习前一天做过记号的单词, 主要时间用来学习新单词<br>(5)整本书一轮背完后, 重复2~4步骤</p>
<p><span style="color:#F00;font-size:16px"><strong>3.一个重要的细节,把每个单词都读出来</strong></span><br>读出来可以强化记忆</p>
<h2 id="四-最后一件事-马上去背"><a href="#四-最后一件事-马上去背" class="headerlink" title="四.最后一件事: 马上去背"></a>四.最后一件事: 马上去背</h2><p>李笑来: 把自己当做一台机器吧,暂时别把自己当人看。因为人是有各种各样的感觉的,其实各种各样的感觉都是浪费时间的:”沮丧”,”焦虑”,除了浪费时间之外没有任何用处;即便是开心幸福,也同样是time-consuming。机器的好处是永远可以定时定量完成制定任务。该干嘛干嘛是成功者朴素的信条。成功之后,没有人说你是”机器”,”呆子”或者”疯子”,所有人对你只有羡慕。不要半途而废,这样变态的事情,我们这辈子只需要做这么一次。做就做到最好,做就一定要坚持。坚持不下次就想想这句话: 失败只有一种,就是半途而废。</p>
<h1 id="0x03-词根词缀法-让单词记忆效率翻倍"><a href="#0x03-词根词缀法-让单词记忆效率翻倍" class="headerlink" title="0x03.词根词缀法: 让单词记忆效率翻倍"></a><span style="color:#436EEE;font-size:24px">0x03.词根词缀法: 让单词记忆效率翻倍</span></h1><p><strong>词根词缀的概念: 词根词缀 &#x3D; 汉字的偏旁部首</strong></p>
<p>词根(root) 每个单词都有, 单词的核心片段,用来揭示单词的核心意义<br>词缀(affix) 可以没有, 位于单词最前面或者最后面的,对词义加以限制的片段分为前缀和后缀</p>
<h2 id="一-前缀"><a href="#一-前缀" class="headerlink" title="一.前缀"></a>一.前缀</h2><p>用来确定单词的方向<br>具体: 前进&#x2F;后退, 向上&#x2F;向下, 之前&#x2F;之后等等<br>抽象: 正确&#x2F;错误, 肯定&#x2F;否定等等<br>其他补充意义: 数量等</p>
<p><span style="color:#F00;font-size:16px"><strong>1.表示否定意义的前缀</strong></span><br>non-, un-, in&#x2F;im, dis-, ab-, de-, counter, mis-等<br>例如: mis- + lead (领导、引领) &#x3D; mislead(误导)<br>　　mis- + fortune (幸运、运气) &#x3D; misfortune (灾难,不幸)<br>　　mistake (错误)</p>
<p><span style="color:#F00;font-size:16px"><strong>2.加强语气的前缀</strong></span><br>en-, super- 等<br>例如: en- + sure(确定的) &#x3D; ensure(确保)<br>　　super- + man(人) &#x3D; Superman(超人)</p>
<p><span style="color:#F00;font-size:16px"><strong>3.表示时间的前缀</strong></span><br>在..之前: pre-, pro-, ante等<br>例如: prepare(准备)<br>在..之后: post-, after-等<br>例如: postwar(战后), afterwards(在那之后)</p>
<p><span style="color:#F00;font-size:16px"><strong>4.表示地点方位的前缀</strong></span></p>
<table>
<thead>
<tr>
<th align="center">前缀</th>
<th align="center">例词</th>
</tr>
</thead>
<tbody><tr>
<td align="center">前: pro-, fore-</td>
<td align="center">forehead(额头)</td>
</tr>
<tr>
<td align="center">后: after-, back-</td>
<td align="center">afternoon(午后)</td>
</tr>
<tr>
<td align="center">上: up</td>
<td align="center">upstairs(楼上)</td>
</tr>
<tr>
<td align="center">下:down-, sub-</td>
<td align="center">downstairs(楼下), subway(地铁)</td>
</tr>
<tr>
<td align="center">右:dextr-</td>
<td align="center">dexterous(灵巧的)</td>
</tr>
<tr>
<td align="center">左:levo-</td>
<td align="center">levofloxacin(左氧氟沙星)</td>
</tr>
<tr>
<td align="center">里:in-</td>
<td align="center">inside(里面)</td>
</tr>
<tr>
<td align="center">外:out-, outer-</td>
<td align="center">outside(外面的)</td>
</tr>
<tr>
<td align="center">..之间:inter-</td>
<td align="center">internet(互联网), international(国际的)</td>
</tr>
</tbody></table>
<p><span style="color:#F00;font-size:16px"><strong>5.表示数量的前缀</strong></span><br>一个: uni-<br>例如: unique(独一无二的), unicorn(独角兽)<br>两个: bi-<br>例如: bipolar(两极), bilinguist通晓两种语言的人</p>
<h2 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h2><p>确定词性</p>
<p><span style="color:#F00;font-size:16px"><strong>1.名词性后缀</strong></span><br>age-: 表示行为和状态的总称<br>例: percentage(百分数)<br>-ence, -ance: 表示性质和动作<br>例: different(不同的), influence(影响), violence(暴力), importance(重要性)<br>-ion, -sion, -tion, -ation: 把动词变成名词<br>例: compete(v.竞争) -&gt;competetion(n.竞争)<br>-er: 有时是普通名词后缀, 有时专门表示”…的人”<br>例: read(读书) -&gt; reader(读者)<br>write(写) -&gt; writer(作家) </p>
<p><span style="color:#F00;font-size:16px"><strong>2.形容词后缀</strong></span><br>-able, ible: 可能的, 可以的<br>例: acceptable(可接受的), possible(可能的)<br>-al: 典型的形容词后缀<br>例: natural(自然的), special(特殊的), central(中心的), typical(典型的)<br>-ful: 充满…的<br>例: colorful(五颜六色的), stressful(有压力的)</p>
<p><span style="color:#F00;font-size:16px"><strong>3.动词性后缀</strong></span><br>-ate: 最常见的动词性后缀<br>例: operate(操作), anticipate(预期), tolerate(忍受)<br>-en, -ify, -ize: 把名称或形容词转化成动词<br>例: weaken(削弱), beautify(美化), standardize(标准化)</p>
<p><span style="color:#F00;font-size:16px"><strong>4.副词性后缀</strong></span><br>-ly<br>例: happy(快乐的) -&gt; happily(快乐地)</p>
<h2 id="词根"><a href="#词根" class="headerlink" title="词根"></a>词根</h2><p>是单词的最核心部分<br><strong>例子1</strong><br>pol-: 杆子, 棍子<br>pol + e &#x3D; pole(杆子, 棍子)<br>pol + -ite(形容词后缀) &#x3D; polite(礼貌的)<br>im- (否定前缀) + polite &#x3D; impolite(不礼貌的)<br>pol + ar(形容词后缀) &#x3D; polar(极地的)</p>
<p><strong>例子2</strong><br>fact-: 做, 制造<br>fact (事实,真相,也就是已经做了的事), factor(因素, 要素), factory(工厂), manufacture(制造)</p>
<p><strong>例子3</strong><br>vis-:看<br>vision(视觉), visible(看得见), televesion(电视), visit(参观), supervise(监督)</p>
<h2 id="词单"><a href="#词单" class="headerlink" title="词单"></a>词单</h2><h3 id="常用后缀"><a href="#常用后缀" class="headerlink" title="常用后缀"></a>常用后缀</h3><p><img src="https://d2ffutrenqvap3.cloudfront.net/items/3M44391R3C413u400r0p/Jietu20180121-191011.png?v=0b1e6874"><br><img src="https://d2ffutrenqvap3.cloudfront.net/items/2e1j0C1B1S1T2q0n0D1B/Jietu20180121-191031.png?v=6de3ad79"></p>
<h3 id="常用前缀"><a href="#常用前缀" class="headerlink" title="常用前缀"></a>常用前缀</h3><p><img src="https://d2ffutrenqvap3.cloudfront.net/items/0y431O3b0g2N200J3r0l/Jietu20180121-192440.png?v=bbc2ed43"><br><img src="https://d2ffutrenqvap3.cloudfront.net/items/2Z341i3w471n2B041D3Y/Jietu20180121-192503.png?v=105a48f8"><br><img src="https://d2ffutrenqvap3.cloudfront.net/items/3E2n1K2G2z1t3E01173b/Jietu20180121-192525.png?v=cfc734fd"><br><img src="https://d2ffutrenqvap3.cloudfront.net/items/0u3T03333L1s1y191V20/Jietu20180121-192552.png?v=bab4fc8f"></p>
<h3 id="常用100词根"><a href="#常用100词根" class="headerlink" title="常用100词根"></a>常用100词根</h3><p><img src="https://d2ffutrenqvap3.cloudfront.net/items/0k0P1F2H17082B383e3g/Jietu20180121-194408.png?v=eddbb398"><br><img src="https://d2ffutrenqvap3.cloudfront.net/items/1Y3N2r381v2E442h2Q15/Jietu20180121-194430.png?v=990ce1fd"><br><img src="https://d2ffutrenqvap3.cloudfront.net/items/1b3E121G2K2B1m0I0O3P/Jietu20180121-194448.png?v=d285401d"><br><img src="https://d2ffutrenqvap3.cloudfront.net/items/2a0x2C1u2f3Z0Y2r2Q1m/Jietu20180121-194537.png?v=604cff16"><br><img src="https://d2ffutrenqvap3.cloudfront.net/items/3k2W3G082t0P1e1x0b34/Jietu20180121-194610.png?v=02a5184b"><br><img src="https://d2ffutrenqvap3.cloudfront.net/items/2i2e0T3J1d2v3I210V1y/Jietu20180121-194642.png?v=6bd01c29"></p>
<h1 id="0x04-词源记忆法-联想记忆法"><a href="#0x04-词源记忆法-联想记忆法" class="headerlink" title="0x04.词源记忆法+联想记忆法"></a><span style="color:#436EEE;font-size:24px">0x04.词源记忆法+联想记忆法</span></h1><h2 id="文字讲义"><a href="#文字讲义" class="headerlink" title="文字讲义"></a>文字讲义</h2><p><span style="color:#CC0066;font-size:16px">词源的定义</span>:词源就是词根词缀的源头形式</p>
<h3 id="现代英语的来源"><a href="#现代英语的来源" class="headerlink" title="现代英语的来源"></a>现代英语的来源</h3><p>希腊语(6%)、拉丁语(66%)和日耳曼语(26%),剩下的2%是一些因为年代久远无法考证出处的词</p>
<h4 id="1-希腊语"><a href="#1-希腊语" class="headerlink" title="1.希腊语"></a>1.希腊语</h4><p>古希腊是西方文明的发源地,</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liyan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
